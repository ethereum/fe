<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fe Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="quickstart/index.html"><strong aria-hidden="true">1.</strong> Quickstart</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="quickstart/first_contract.html"><strong aria-hidden="true">1.1.</strong> Write your first contract</a></li><li class="chapter-item "><a href="quickstart/deploy_contract.html"><strong aria-hidden="true">1.2.</strong> Deploying a contract to a testnet</a></li></ol></li><li class="chapter-item expanded "><a href="user-guide/index.html"><strong aria-hidden="true">2.</strong> Using Fe</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-guide/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item "><a href="user-guide/projects.html"><strong aria-hidden="true">2.2.</strong> Using projects</a></li><li class="chapter-item "><a href="user-guide/tutorials/index.html"><strong aria-hidden="true">2.3.</strong> Tutorials</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-guide/tutorials/auction.html"><strong aria-hidden="true">2.3.1.</strong> Open auction</a></li></ol></li><li class="chapter-item "><a href="user-guide/example_contracts/index.html"><strong aria-hidden="true">2.4.</strong> Example Contracts</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-guide/example_contracts/auction_contract.html"><strong aria-hidden="true">2.4.1.</strong> Open auction</a></li></ol></li><li class="chapter-item "><a href="user-guide/external_links.html"><strong aria-hidden="true">2.5.</strong> Useful external links</a></li></ol></li><li class="chapter-item expanded "><a href="development/index.html"><strong aria-hidden="true">3.</strong> Development</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="development/build.html"><strong aria-hidden="true">3.1.</strong> Build & Test</a></li><li class="chapter-item "><a href="development/release.html"><strong aria-hidden="true">3.2.</strong> Release</a></li></ol></li><li class="chapter-item expanded "><a href="std/index.html"><strong aria-hidden="true">4.</strong> Standard Library</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/precompiles.html"><strong aria-hidden="true">4.1.</strong> Precompiles</a></li></ol></li><li class="chapter-item expanded "><a href="spec/index.html"><strong aria-hidden="true">5.</strong> Specification (WIP)</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/notation.html"><strong aria-hidden="true">5.1.</strong> Notation</a></li><li class="chapter-item "><a href="spec/lexical_structure/index.html"><strong aria-hidden="true">5.2.</strong> Lexical Structure</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/lexical_structure/keywords.html"><strong aria-hidden="true">5.2.1.</strong> Keywords</a></li><li class="chapter-item "><a href="spec/lexical_structure/identifiers.html"><strong aria-hidden="true">5.2.2.</strong> Identifiers</a></li><li class="chapter-item "><a href="spec/lexical_structure/tokens.html"><strong aria-hidden="true">5.2.3.</strong> Tokens</a></li></ol></li><li class="chapter-item "><a href="spec/comments.html"><strong aria-hidden="true">5.3.</strong> Comments</a></li><li class="chapter-item "><a href="spec/items/index.html"><strong aria-hidden="true">5.4.</strong> Items</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/items/visibility_and_privacy.html"><strong aria-hidden="true">5.4.1.</strong> Visibility and Privacy</a></li><li class="chapter-item "><a href="spec/items/structs.html"><strong aria-hidden="true">5.4.2.</strong> Structs</a></li><li class="chapter-item "><a href="spec/items/traits.html"><strong aria-hidden="true">5.4.3.</strong> Traits</a></li><li class="chapter-item "><a href="spec/items/enums.html"><strong aria-hidden="true">5.4.4.</strong> Enums</a></li><li class="chapter-item "><a href="spec/items/type_aliases.html"><strong aria-hidden="true">5.4.5.</strong> Type Aliases</a></li><li class="chapter-item "><a href="spec/items/contracts.html"><strong aria-hidden="true">5.4.6.</strong> Contracts</a></li><li class="chapter-item "><a href="spec/items/functions/index.html"><strong aria-hidden="true">5.4.7.</strong> Functions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/items/functions/context.html"><strong aria-hidden="true">5.4.7.1.</strong> Context</a></li><li class="chapter-item "><a href="spec/items/functions/self.html"><strong aria-hidden="true">5.4.7.2.</strong> Self</a></li></ol></li></ol></li><li class="chapter-item "><a href="spec/statements/index.html"><strong aria-hidden="true">5.5.</strong> Statements</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/statements/pragma.html"><strong aria-hidden="true">5.5.1.</strong> pragma Statement</a></li><li class="chapter-item "><a href="spec/statements/const.html"><strong aria-hidden="true">5.5.2.</strong> const Statement</a></li><li class="chapter-item "><a href="spec/statements/let.html"><strong aria-hidden="true">5.5.3.</strong> let Statement</a></li><li class="chapter-item "><a href="spec/statements/assign.html"><strong aria-hidden="true">5.5.4.</strong> Assignment Statement</a></li><li class="chapter-item "><a href="spec/statements/augassign.html"><strong aria-hidden="true">5.5.5.</strong> Augmenting Assignment Statement</a></li><li class="chapter-item "><a href="spec/statements/revert.html"><strong aria-hidden="true">5.5.6.</strong> revert Statement</a></li><li class="chapter-item "><a href="spec/statements/return.html"><strong aria-hidden="true">5.5.7.</strong> return Statement</a></li><li class="chapter-item "><a href="spec/statements/if.html"><strong aria-hidden="true">5.5.8.</strong> if Statement</a></li><li class="chapter-item "><a href="spec/statements/for.html"><strong aria-hidden="true">5.5.9.</strong> for Statement</a></li><li class="chapter-item "><a href="spec/statements/while.html"><strong aria-hidden="true">5.5.10.</strong> while Statement</a></li><li class="chapter-item "><a href="spec/statements/break.html"><strong aria-hidden="true">5.5.11.</strong> break Statement</a></li><li class="chapter-item "><a href="spec/statements/continue.html"><strong aria-hidden="true">5.5.12.</strong> continue Statement</a></li><li class="chapter-item "><a href="spec/statements/match.html"><strong aria-hidden="true">5.5.13.</strong> match Statement</a></li><li class="chapter-item "><a href="spec/statements/assert.html"><strong aria-hidden="true">5.5.14.</strong> assert Statement</a></li></ol></li><li class="chapter-item "><a href="spec/expressions/index.html"><strong aria-hidden="true">5.6.</strong> Expressions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/expressions/call.html"><strong aria-hidden="true">5.6.1.</strong> Call expressions</a></li><li class="chapter-item "><a href="spec/expressions/tuple.html"><strong aria-hidden="true">5.6.2.</strong> Tuple expressions</a></li><li class="chapter-item "><a href="spec/expressions/list.html"><strong aria-hidden="true">5.6.3.</strong> List expressions</a></li><li class="chapter-item "><a href="spec/expressions/struct.html"><strong aria-hidden="true">5.6.4.</strong> Struct expressions</a></li><li class="chapter-item "><a href="spec/expressions/indexing.html"><strong aria-hidden="true">5.6.5.</strong> Index expressions</a></li><li class="chapter-item "><a href="spec/expressions/attribute.html"><strong aria-hidden="true">5.6.6.</strong> Attribute expressions</a></li><li class="chapter-item "><a href="spec/expressions/name.html"><strong aria-hidden="true">5.6.7.</strong> Name expressions</a></li><li class="chapter-item "><a href="spec/expressions/path.html"><strong aria-hidden="true">5.6.8.</strong> Path expressions</a></li><li class="chapter-item "><a href="spec/expressions/literal.html"><strong aria-hidden="true">5.6.9.</strong> Literal expressions</a></li><li class="chapter-item "><a href="spec/expressions/arithmetic_operators.html"><strong aria-hidden="true">5.6.10.</strong> Arithmetic Operators</a></li><li class="chapter-item "><a href="spec/expressions/comparison_operators.html"><strong aria-hidden="true">5.6.11.</strong> Comparison Operators</a></li><li class="chapter-item "><a href="spec/expressions/boolean_operators.html"><strong aria-hidden="true">5.6.12.</strong> Boolean Operators</a></li><li class="chapter-item "><a href="spec/expressions/unary_operators.html"><strong aria-hidden="true">5.6.13.</strong> Unary Operators</a></li></ol></li><li class="chapter-item "><a href="spec/type_system/index.html"><strong aria-hidden="true">5.7.</strong> Type System</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/type_system/types/index.html"><strong aria-hidden="true">5.7.1.</strong> Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/type_system/types/boolean.html"><strong aria-hidden="true">5.7.1.1.</strong> Boolean Type</a></li><li class="chapter-item "><a href="spec/type_system/types/contract.html"><strong aria-hidden="true">5.7.1.2.</strong> Contract Type</a></li><li class="chapter-item "><a href="spec/type_system/types/numeric.html"><strong aria-hidden="true">5.7.1.3.</strong> Numeric Types</a></li><li class="chapter-item "><a href="spec/type_system/types/tuple.html"><strong aria-hidden="true">5.7.1.4.</strong> Tuple Types</a></li><li class="chapter-item "><a href="spec/type_system/types/array.html"><strong aria-hidden="true">5.7.1.5.</strong> Array Types</a></li><li class="chapter-item "><a href="spec/type_system/types/struct.html"><strong aria-hidden="true">5.7.1.6.</strong> Struct Types</a></li><li class="chapter-item "><a href="spec/type_system/types/enum.html"><strong aria-hidden="true">5.7.1.7.</strong> Enum Types</a></li><li class="chapter-item "><a href="spec/type_system/types/address.html"><strong aria-hidden="true">5.7.1.8.</strong> Address Type</a></li><li class="chapter-item "><a href="spec/type_system/types/map.html"><strong aria-hidden="true">5.7.1.9.</strong> Map Type</a></li><li class="chapter-item "><a href="spec/type_system/types/string.html"><strong aria-hidden="true">5.7.1.10.</strong> String Type</a></li><li class="chapter-item "><a href="spec/type_system/types/unit.html"><strong aria-hidden="true">5.7.1.11.</strong> Unit Type</a></li><li class="chapter-item "><a href="spec/type_system/types/function.html"><strong aria-hidden="true">5.7.1.12.</strong> Function Type</a></li></ol></li></ol></li><li class="chapter-item "><a href="spec/data_layout/index.html"><strong aria-hidden="true">5.8.</strong> Data Layout</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/data_layout/stack.html"><strong aria-hidden="true">5.8.1.</strong> Stack</a></li><li class="chapter-item "><a href="spec/data_layout/storage/index.html"><strong aria-hidden="true">5.8.2.</strong> Storage</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/data_layout/storage/constant_size_values_in_storage.html"><strong aria-hidden="true">5.8.2.1.</strong> Constant size values in storage</a></li><li class="chapter-item "><a href="spec/data_layout/storage/maps_in_storage.html"><strong aria-hidden="true">5.8.2.2.</strong> Maps in storage</a></li><li class="chapter-item "><a href="spec/data_layout/storage/to_mem_function.html"><strong aria-hidden="true">5.8.2.3.</strong> to_mem() function</a></li></ol></li><li class="chapter-item "><a href="spec/data_layout/memory/index.html"><strong aria-hidden="true">5.8.3.</strong> Memory</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spec/data_layout/memory/sequence_types_in_memory.html"><strong aria-hidden="true">5.8.3.1.</strong> Sequence types in memory</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="release_notes.html"><strong aria-hidden="true">7.</strong> Release Notes</a></li><li class="chapter-item expanded "><a href="code_of_conduct.html"><strong aria-hidden="true">8.</strong> Code of Conduct</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fe Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><br /><br /></p>
<center><img alt="Fe logo" src="images/fe.png" height="300" ></center>
<h2 id="what-is-fe"><a class="header" href="#what-is-fe">What is Fe?</a></h2>
<p>Fe is the <em>next generation smart contract language for Ethereum</em>.</p>
<p>Fe is a <a href="https://ethereum.org/en/smart-contracts/#introduction-to-smart-contracts">smart contract</a> language that strives to make developing Ethereum smart contract development <em>safer, simpler and more fun</em>.</p>
<p>Smart contracts are programs executed by a computer embedded into Ethereum clients known as the <a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine (EVM)</a>. The EVM executes bytecode instructions that are not human readable. Therefore, developers use higher-level languages that compiles to EVM bytecode. </p>
<p>Fe is one of these languages.</p>
<h2 id="why-fe"><a class="header" href="#why-fe">Why Fe?</a></h2>
<p>Fe aims to make writing secure smart contract code a great experience. With Fe, writing safe code feels natural and fun.</p>
<p>Fe shares similar syntax with the popular languages <a href="https://doc.rust-lang.org/book/">Rust</a> and <a href="https://www.python.org/">Python</a>, easing the learning curve for new users. It also implements the best features from Rust to limit dynamic behaviour while also maximizing expressiveness, meaning you can write clean, readable code without sacrificing compile time guarantees.</p>
<p>Fe is:</p>
<ul>
<li>statically typed</li>
<li>expressive</li>
<li>compiled using Yul</li>
<li>built to a detailed language specification</li>
<li>able to limit dynamic behaviour</li>
<li>rapidly evolving!</li>
</ul>
<h2 id="who-is-fe-for"><a class="header" href="#who-is-fe-for">Who is Fe for?</a></h2>
<p>Fe is for <em>anyone that develops using the EVM</em>!</p>
<p>Fe compiles to EVM bytecode that can be deployed directly onto Ethereum and EVM-equivalent blockchains.</p>
<p>Fe's syntax will feel familiar to Rust and Python developers.</p>
<p>Here's what a minimal contract looks like in Fe:</p>
<pre><code class="language-fe">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;

  pub fn sign(mut self, ctx: Context, book_msg: String&lt;100&gt;) {
      self.messages[ctx.msg_sender()] = book_msg
  }
}
</code></pre>
<h2 id="what-problems-does-fe-solve"><a class="header" href="#what-problems-does-fe-solve">What problems does Fe solve?</a></h2>
<p>One of the pain points with smart contract languages is that there can be ambiguities in how the compiler translates the human readable code into EVM bytecode. This can lead to security flaws and unexpected behaviours. </p>
<p>The details of the EVM can also cause the higher level languages to be less intuitive and harder to master than some other languages. These are some of the pain points Fe aims to solve. By striving to <em>maximize both human readability and bytecode predictability</em>, Fe will provide an enhanced developer experience for everyone working with the EVM.</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>You can read much more information about Fe in these docs. If you want to get building, you can begin with our <a href="quickstart/index.html">Quickstart guide</a>.</p>
<p>You can also get involved in the Fe community by contributing code or documentation to the project Github or joining the conversation on <a href="https://discord.gg/ywpkAXFjZH">Discord</a>. Learn more on our <a href="contributing.html">Contributing</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Let's get started with Fe! </p>
<p>In this section you will learn how to write and deploy your first contract.</p>
<ul>
<li><a href="quickstart/first_contract.html">Writing your first contract</a></li>
<li><a href="quickstart/deploy_contract.html">Deploying a contract to a testnet</a></li>
</ul>
<h2 id="download-and-install-fe"><a class="header" href="#download-and-install-fe">Download and install Fe</a></h2>
<p>Before you dive in, you need to download and install Fe. 
For this quickstart you should simply download the binary from <a href="https://fe-lang.org/">fe-lang.org</a>.</p>
<p>Then change the name and file permissions:</p>
<pre><code class="language-sh">mv fe_amd64 fe
chmod +x fe
</code></pre>
<p>Now you are ready to do the quickstart tutorial!</p>
<p>For more detailed information on installing Fe, or to troubleshoot, see the <a href="quickstart/../user-guide/installation.html">Installation</a> page in our user guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="write-your-first-fe-contract"><a class="header" href="#write-your-first-fe-contract">Write your first Fe contract</a></h2>
<p>Now that we have the compiler installed let's write our first contract. A contract contains the code that will be deployed to the Ethereum blockchain and resides at a specific address.</p>
<p>The code of the contract dictates how:</p>
<ul>
<li>it manipulates its own state</li>
<li>interacts with other contracts</li>
<li>exposes external APIs to be called from other contracts or users</li>
</ul>
<p>To keep things simple we will just write a basic <em>guestbook</em> where people can leave a message associated with their Ethereum address.</p>
<blockquote>
<p>Note: Real code would not instrument the Ethereum blockchain in such a way as it is a waste of precious resources. This code is for demo purposes only.</p>
</blockquote>
<h3 id="create-a-guest_bookfe-file"><a class="header" href="#create-a-guest_bookfe-file">Create a <code>guest_book.fe</code> file</a></h3>
<p>Fe code is written in files ending on the <code>.fe</code> file extension. Let's create a file <code>guest_book.fe</code> and put in the following content.</p>
<pre><code class="language-fe">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;
}
</code></pre>
<p>Here we're using a <a href="quickstart/../spec/type_system/types/map.html"><code>map</code></a> to associate messages with Ethereum addresses.
The messages will simply be a <a href="quickstart/../spec/type_system/types/string.html"><code>string</code></a> of a maximum length of <code>100</code> written as <code>String&lt;100&gt;</code>.
The addresses are represented by the builtin <a href="quickstart/../spec/type_system/types/address.html"><code>address</code></a> type.</p>
<p>Execute <code>./fe build guest_book.fe</code> to compile the file. The compiler tells us that it compiled our contract and that it has put the artifacts into a subdirectory called <code>output</code>.</p>
<pre><code>Compiled guest_book.fe. Outputs in `output`
</code></pre>
<p>If we examine the <code>output</code> directory we'll find a subdirectory <code>GuestBook</code> with a <code>GuestBook_abi.json</code> and a <code>GuestBook.bin</code> file.</p>
<pre><code>‚îú‚îÄ‚îÄ fe
‚îú‚îÄ‚îÄ guest_book.fe
‚îî‚îÄ‚îÄ output
    ‚îî‚îÄ‚îÄ GuestBook
        ‚îú‚îÄ‚îÄ GuestBook_abi.json
        ‚îî‚îÄ‚îÄ GuestBook.bin
</code></pre>
<p>The <code>GuestBook_abi.json</code> is a JSON representation that describes the binary interface of our contract but since our contract doesn't yet expose anything useful its content for now resembles an empty array.</p>
<p>The <code>GuestBook.bin</code> is slightly more interesting containing what looks like a gibberish of characters which in fact is the compiled binary contract code written in <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> characters.</p>
<p>We don't need to do anything further yet with these files that the compiler produces but they will become important when we get to the point where we want to deploy our code to the Ethereum blockchain.</p>
<h3 id="add-a-method-to-sign-the-guest-book"><a class="header" href="#add-a-method-to-sign-the-guest-book">Add a method to sign the guest book</a></h3>
<p>Let's focus on the functionality of our world changing application and add a method to sign the guestbook.</p>
<pre><code class="language-fe">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;

  pub fn sign(mut self, ctx: Context, book_msg: String&lt;100&gt;) {
      self.messages[ctx.msg_sender()] = book_msg
  }
}
</code></pre>
<p>In Fe, every method that is defined without the <a href="quickstart/../spec/items/visibility_and_privacy.html"><code>pub</code></a> keyword becomes private. Since we want people to interact with our contract and call the <code>sign</code> method we have to prefix it with <code>pub</code>.</p>
<p>Let's recompile the contract again and see what happens.</p>
<pre><code>Failed to write output to directory: `output`. Error: Directory 'output' is not empty. Use --overwrite to overwrite.
</code></pre>
<p>Oops, the compiler is telling us that the <code>output</code> directory is a non-empty directory and plays it safe by asking us if we are sure that we want to overwrite it. We have to use the <code>--overwrite</code> flag to allow the compiler to overwrite what is stored in the <code>output</code> directory.</p>
<p>Let's try it again with <code>./fe build guest_book.fe --overwrite</code>.</p>
<p>This time it worked and we can also see that the <code>GuestBook_abi.json</code> has become slightly more interesting.</p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;sign&quot;,
    &quot;type&quot;: &quot;function&quot;,
    &quot;inputs&quot;: [
      {
        &quot;name&quot;: &quot;book_msg&quot;,
        &quot;type&quot;: &quot;bytes100&quot;
      }
    ],
    &quot;outputs&quot;: []
  }
]
</code></pre>
<p>Since our contract now has a public <code>sign</code> method the corresponding ABI has changed accordingly.</p>
<h3 id="add-a-method-to-read-a-message"><a class="header" href="#add-a-method-to-read-a-message">Add a method to read a message</a></h3>
<p>To make the guest book more useful we will also add a method <code>get_msg</code> to read entries from a given address.</p>
<pre><code class="language-fe ignore">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;

  pub fn sign(mut self, ctx: Context, book_msg: String&lt;100&gt;) {
      self.messages[ctx.msg_sender()] = book_msg
  }

  pub fn get_msg(self, addr: address) -&gt; String&lt;100&gt; {
      return self.messages[addr]
  }
}
</code></pre>
<p>However, we will hit another error as we try to recompile the current code.</p>
<pre><code>Unable to compile guest_book.fe.
error: value must be copied to memory
  ‚îå‚îÄ guest_book.fe:10:14
  ‚îÇ
8 ‚îÇ       return self.messages[addr]
  ‚îÇ              ^^^^^^^^^^^^^^^^^^^ this value is in storage
  ‚îÇ
  = Hint: values located in storage can be copied to memory using the `to_mem` function.
  = Example: `self.my_array.to_mem()`
</code></pre>
<p>When we try to return a reference type such as an array from the storage of the contract we have to explicitly copy it to memory using the <a href="quickstart/../spec/data_layout/storage/to_mem_function.html"><code>to_mem()</code></a> function.</p>
<blockquote>
<p>Note: In the future Fe will likely introduce immutable storage pointers which might affect these semantics.</p>
</blockquote>
<p>The code should compile fine when we change it accordingly.</p>
<pre><code class="language-fe">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;

  pub fn sign(mut self, ctx: Context, book_msg: String&lt;100&gt;) {
      self.messages[ctx.msg_sender()] = book_msg
  }

  pub fn get_msg(self, addr: address) -&gt; String&lt;100&gt; {
      return self.messages[addr].to_mem()
  }
}
</code></pre>
<p>Congratulations! You finished your first little Fe project. üëè
In the next chapter we will learn how to deploy our code and tweak it a bit further.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deploy-your-contract"><a class="header" href="#deploy-your-contract">Deploy your contract.</a></h2>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You should have compiled the <code>GuestBook</code> contract and have both <code>Guestbook_abi.json</code> and <code>GuestBook.bin</code> available in your <code>outputs</code> folder.
If you don't have any of these components, please revisit <a href="quickstart/./first_contract.html">Write your first contract</a>.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>When you develop smart contracts it is common to test them on local blockchains first because they are quick and easy to create and it doesn't matter if you make mistakes - there is nothing of real value secured by the blockchain as it only exists on your computer. Later, you can deploy your contract on a public test network to see how it behaves in a more realistic environment where other developers are also testing their code. Finally, when you are very confident that your contract is ready, you can deploy to Ethereum Mainnet (or one of its live Layer-2 networks). Once the contract is deployed on a &quot;live&quot; network, you are handling assets with real-world value!</p>
<p>In this guide, you will deploy your contract to a <strong>local blockchain</strong>. This will be an &quot;ephemeral&quot; blockchain, meaning it is completely destroyed every time you shut it down and recreated from scratch every time you start it up - it won't save its state when you shut it down. The benefit of this is quick and easy development, and you don't need to find test ETH to pay gas fees. Later in the guide, you will learn how to deploy to a live public test network too.</p>
<h2 id="your-developer-environment"><a class="header" href="#your-developer-environment">Your developer environment</a></h2>
<p>Everything in this tutorial can be done by sending JSON data directly to an Ethereum node. However, this is often awkward and error-prone, so a rich ecosystem of tooling has been developed to allow developers to interact with Ethereum in familiar languages or using abstractions that simplify the process.</p>
<p>In this guide, you will use <a href="https://book.getfoundry.sh/">Foundry</a> which is a very lightweight set of command-line tools for managing smart contract development. If you already have Foundry installed, head straight to the next section. If you need to install Foundry, head to <a href="https://getfoundry.sh">getfoundry.sh</a> and follow the installation steps.</p>
<blockquote>
<p>Note: If you are a seasoned smart contract developer, feel free to follow the tutorial using your own toolchain.</p>
</blockquote>
<h2 id="deploying-to-a-local-network"><a class="header" href="#deploying-to-a-local-network">Deploying to a local network</a></h2>
<p>Foundry has its own local network called <a href="https://book.getfoundry.sh/reference/anvil/">Anvil</a>. You can use it to create a local blockchain on your computer. Open a terminal and run the following very simple command:</p>
<pre><code class="language-sh">anvil 
</code></pre>
<p>You will see some ASCII art and configuration details in the terminal. Anvil creates a set of accounts that you can use on this network. The account addresses and private keys are displayed in the console (<strong>never</strong> use these accounts to interact with any live network). You will also see a line reading <code>listening on 127.0.0.1:8545</code>. This indicates that your local node is listening for HTTP traffic on your local network on port 8545 - this is important because this is how you will send the necessary information to your node so that it can be added to the blockchain, and how you will interact with the contract after it is deployed.</p>
<blockquote>
<p>Note: Anvil needs to keep running throughout this tutorial - if you close the terminal your blockchain will cease to exist. Once Anvil has started, open a <strong>new terminal</strong> tab/window to run the rest of the commands in this guide.</p>
</blockquote>
<h3 id="making-the-deployment-transaction"><a class="header" href="#making-the-deployment-transaction">Making the deployment transaction</a></h3>
<p>In the previous guide you wrote the following contract, and compiled it using <code>./fe build guest_book.fe --overwrite</code> to obtain the contract bytecode. This compilation stage converts the human-readable Fe code into a format that can be efficiently executed by Ethereum's embedded computer, known as the Ethereum Virtual Machine (EVM). The bytecode is stored at an address on the blockchain. The contract functions are invoked by sending instructions in a transaction to that address.</p>
<pre><code class="language-fe">contract GuestBook {
  messages: Map&lt;address, String&lt;100&gt;&gt;

  pub fn sign(mut self, ctx: Context, book_msg: String&lt;100&gt;) {
    self.messages[ctx.msg_sender()] = book_msg
  }

  pub fn get_msg(self, addr: address) -&gt; String&lt;100&gt; {
    return self.messages[addr].to_mem()
  }
}
</code></pre>
<p>To make the deployment, we will need to send a transaction to your node via its exposed HTTP port (<code>8545</code>). </p>
<p>The following command deploys the Guestbook contract to your local network. Grab the private key of one of your accounts from the information displayed in the terminal running Anvil.</p>
<pre><code class="language-sh">cast send --rpc-url localhost:8545 --private-key &lt;your-private-key&gt; --create $(cat output/GuestBook/GuestBook.bin)
</code></pre>
<p>Here's what the response was at the time of writing this tutorial.</p>
<pre><code class="language-sh">blockHash               0xcee9ff7c0b57822c5f6dd4fbd3a7e9eadb594b84d770f56f393f137785a52702
blockNumber             1
contractAddress         0x5FbDB2315678afecb367f032d93F642f64180aa3
cumulativeGasUsed       196992
effectiveGasPrice       4000000000
gasUsed                 196992
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root                    
status                  1
transactionHash         0x3fbde2a994bf2dec8c11fb0390e9d7fbc0fa1150f5eab8f33c130b4561052622
transactionIndex        0
type                    2
</code></pre>
<p>This response tells you that your contract has been deployed to the blockchain. The transaction was included in block number 1, and the address it was deployed to is provided in the <code>contractAddress</code> field - you need this address to interact with the contract.</p>
<blockquote>
<p>Note: Don't assume responses to be identical when following the tutorial. Due to the nature of the blockchain environment the content of the responses will always differ slightly.</p>
</blockquote>
<h3 id="signing-the-guest-book"><a class="header" href="#signing-the-guest-book">Signing the guest book</a></h3>
<p>Now that the contract is deployed to the blockchain, you can send a transaction to sign it with a custom message. You will sign it from the same address that was used to deploy the contract, but there is nothing preventing you from using any account for which you have the private key (you could experiment by signing from all ten accounts created by Anvil, for example).</p>
<p>The following command will send a transaction to call <code>sign(string)</code> on our freshly deployed Guestbook contract sitting at address <code>0x810cbd4365396165874c054d01b1ede4cc249265</code> with the message <em>&quot;We &lt;3 Fe&quot;</em>.</p>
<pre><code class="language-sh">cast send --rpc-url http://localhost:8545 --private-key &lt;your-private-key&gt; &lt;contract-address&gt; &quot;sign(string)&quot; '&quot;We &lt;3 Fe&quot;'
</code></pre>
<p>The response will look approximately as follows:</p>
<pre><code class="language-sh">blockHash               0xb286898484ae737d22838e27b29899b327804ec45309e47a75b18cfd7d595cc7
blockNumber             2
contractAddress         
cumulativeGasUsed       36278
effectiveGasPrice       3767596722
gasUsed                 36278
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root                    
status                  1
transactionHash         0x309bcea0a77801c15bb7534beab9e33dcb613c93cbea1f12d7f92e4be5ecab8c
transactionIndex        0
type                    2
</code></pre>
<h3 id="reading-the-signatures"><a class="header" href="#reading-the-signatures">Reading the signatures</a></h3>
<p>The <code>get_msg(address)</code> API allows you to read the messages added to the guestbook for a given address. It will give us a response of 100 zero bytes for any address that hasn't yet signed the guestbook.</p>
<p>Since reading the messages doesn't change any state within the blockchain, you don't have to send an actual transaction. Instead, you can perform a <em>call</em> against the local state of the node that you are querying.</p>
<p>To do that run:</p>
<pre><code class="language-sh">$ cast call --rpc-url http://localhost:8545 &lt;contract-address&gt; &quot;get_msg(address)&quot; &lt;your-account-address-that-signed-the-guestbook&gt;
</code></pre>
<p>Notice that the command doesn't need to provide a private key simply because we are not sending an actual transaction.</p>
<p>The response arrives in the form of hex-encoded bytes padded with zeroes: </p>
<pre><code class="language-sh">0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000087765203c33204665000000000000000000000000000000000000000000000000
</code></pre>
<p>Foundry provides a built-in method to convert this hex string into human-readable ASCII. You can do this as follows:</p>
<pre><code class="language-sh">cast to_ascii &quot;0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000087765203c33204665000000000000000000000000000000000000000000000000&quot;
</code></pre>
<p>or simply pipe the output of the <code>cast call</code> to <code>to_ascii</code> to do the query and conversion in a single command:</p>
<pre><code class="language-sh">cast call --rpc-url https://rpc.sepolia.org &lt;contract-address&gt; &quot;get_msg(address)&quot; &lt;your-account-address-that-signed-the-guestbook&gt; | cast --to-ascii
</code></pre>
<p>Either way, the response will be the message you passed to the <code>sign(string)</code> function.</p>
<pre><code class="language-sh">&quot;We &lt;3 Fe&quot;
</code></pre>
<p>Congratulations! You've deployed real Fe code to a local blockchain! ü§ñ</p>
<h2 id="deploying-to-a-public-test-network"><a class="header" href="#deploying-to-a-public-test-network">Deploying to a public test network</a></h2>
<p>Now you have learned how to deploy your contract to a local blockchain, you can consider deploying it to a public test network too. For more complex projects this can be very beneficial because it allows many users to interact with your contract, simulates real network conditions and allows you to interact with other existing contracts on the network. However, to use a public testnet you need to obtain some of that testnet's gas token. </p>
<p>In this guide you will use the Sepolia test network, meaning you will need some SepoliaETH. SepoliaETH has no real-world value - it is only required to pay gas fees on the network. If you don't have any SepoliaETH yet, you can <a href="https://ethereum.org/en/developers/docs/networks/#sepolia">request some SepoliaETH</a> from one of the faucets that are listed on the ethereum.org website.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: It is good practice to <strong>never</strong> use an Ethereum account for a testnet that is also used for the actual Ethereum mainnet.</p>
</blockquote>
<p>Assuming you have some SepoliaETH, you can repeat the steps from the local blockchain example, however, instead of pointing Foundry to the RPC endpoint for your Anvil node, you need to point it to a node connected to the Sepolia network. There are several options for this:</p>
<ul>
<li>If you run your own node, connect it to the Sepolia network and let it sync. make sure you expose an http port or enable IPC transport.</li>
<li>You can use an RPC provider such as <a href="https://www.alchemy.com/">Alchemy</a> or <a href="https://infura.io/">Infura</a> </li>
<li>You can use an open public node such as <code>https://rpc.sepolia.org</code>.</li>
</ul>
<p>Whichever method you choose, you will have an RPC endpoint for a node connected to Sepolia. You can replace the <code>http://localhost:8545</code> in the commands with your new endpoint. For example, to deploy the contract using the open public endpoint:</p>
<pre><code class="language-sh">cast send --rpc-url https://rpc.sepolia.org --private-key &lt;your-private-key&gt; --create $(cat output/GuestBook/GuestBook.bin)
</code></pre>
<p>Now you have deployed the contract to a public network and anyone can interact with it. </p>
<p>To demonstrate, you can check out previous versions of this contract deployed on Sepolia in the past:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>address</th><th>link</th></tr></thead><tbody>
<tr><td>deploy tx hash</td><td>0x31b41a4177d7eb66f5ea814959b2c147366b6323f17b6f7060ecff424b58df76</td><td><a href="https://sepolia.etherscan.io/tx/0x31b41a4177d7eb66f5ea814959b2c147366b6323f17b6f7060ecff424b58df76">etherscan</a></td></tr>
<tr><td>contract address</td><td>0x810cbd4365396165874C054d01B1Ede4cc249265</td><td><a href="https://sepolia.etherscan.io/address/0x810cbd4365396165874c054d01b1ede4cc249265">etherscan</a></td></tr>
</tbody></table>
</div>
<p>Note that calling the <code>sign(string)</code> function will cost you some SepoliaETH because the function changes the state of the blockchain (it adds a message to the contract storage). However, <code>get_msg(address)</code> does not cost any gas because it is a simple lookup in the node's local database.</p>
<p>Congratulations! You've deployed real Fe code to a live network ü§ñ</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Well done!</p>
<p>You have now written and compiled a Fe contract and deployed it to both a local blockchain and a live public test network! You also learned how to interact with the deployed contract using transactions and calls.</p>
<p>Here's some ideas for what you could do next:</p>
<ul>
<li>Experiment with different developer tooling</li>
<li>Get more comfortable with Foundry by exploring the <a href="https://book.getfoundry.sh/">documentation</a></li>
<li>Repeat the steps in this guide but for a more complex contract - be creative!</li>
<li>Continue to the <a href="quickstart/../user-guide/index.html">Using Fe</a> pages to explore Fe more deeply.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User guide</a></h1>
<p>Welcome to the Fe user guide!</p>
<p>Here you can find information about how to use Fe to develop smart contracts.</p>
<p>Read more about:</p>
<ul>
<li><a href="user-guide/installation.html">Installing</a> Fe</li>
<li>organizing your code using <a href="user-guide/projects.html">projects</a></li>
</ul>
<p>We are <em><strong>still building</strong></em> this section of the site, but you can expect to find other materials such as reference documentation, project examples and walkthrough guides here soon!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>At this point Fe is available for <strong>Linux</strong> and <strong>MacOS</strong> natively but can also be installed on <strong>Windows</strong> via <a href="https://learn.microsoft.com/en-us/windows/wsl/about">WSL</a>.</p>
<blockquote>
<p>Note: If you happen to be a Windows developer, consider getting involved
and help us to support the Windows platform natively. <a href="https://github.com/ethereum/fe/issues/62">Here would be a good place to start.</a></p>
</blockquote>
<p>On a computer with MacOS and an ARM chip, you need to install Rosetta, Apple's x86-to-ARM translator, to be able to run the executable. </p>
<pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license
</code></pre>
<h2 id="package-managers"><a class="header" href="#package-managers">Package managers</a></h2>
<p>Fe can be installed from <a href="https://brew.sh/">Homebrew</a>. Homebrew is available for Mac, Linux and Windows (via <a href="https://learn.microsoft.com/en-us/windows/wsl/about">WSL</a>). The following command installs Fe and exposes it as <code>fe</code> without any further configuration necessary:</p>
<pre><code class="language-sh">brew install fe-lang/tap/fe
</code></pre>
<h2 id="download-the-compiler"><a class="header" href="#download-the-compiler">Download the compiler</a></h2>
<p>Fe is distributed via a single executable file linked from the <a href="https://fe-lang.org">home page</a>. In the future we will make sure it can be installed through a variety of popular package managers such as <code>apt</code>.</p>
<p>Depending on your operating system, the file that you download is either named <code>fe_amd64</code> or <code>fe_mac</code>.</p>
<blockquote>
<p>Note: We will rename the file to <code>fe</code> and assume that name for the rest of the guide. In the future when Fe can be installed via other mechanisms we can assume <code>fe</code> to become the canonical command name.</p>
</blockquote>
<h3 id="add-permission-to-execute"><a class="header" href="#add-permission-to-execute">Add permission to execute</a></h3>
<p>In order to be able to execute the Fe compiler we will have to make the file <em>executable</em>. This can be done by navigating to the directory where the file is located and executing <code>chmod + x &lt;filename&gt;</code> (e.g. <code>chmod +x fe</code>).</p>
<p>After we have set the proper permissions we should be able to run <code>./fe</code> and an output that should be roughly comparable to:</p>
<pre><code>fe 0.21.0-alpha
The Fe Developers &lt;snakecharmers@ethereum.org&gt;
An implementation of the Fe smart contract language

USAGE:
    fe_amd64_latest &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    build    Build the current project
    check    Analyze the current project and report errors, but don't build artifacts
    help     Print this message or the help of the given subcommand(s)
    new      Create new fe project
</code></pre>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h2>
<p>You can also build Fe from the source code provided in our Github <a href="https://github.com/ethereum/fe">repository</a>. To do this you will need to have <a href="https://www.rust-lang.org/tools/install">Rust</a> installed. Then, clone the github repository using:</p>
<pre><code class="language-sh">git clone https://github.com/ethereum/fe.git
</code></pre>
<p>Depending on your environment you may need to install some additional packages before building the Fe binary, specifically <code>libboost-all-dev</code>, <code>libclang</code> and <code>cmake</code>. For example, on a Linux system:</p>
<pre><code class="language-sh">sudo apt-get update &amp;&amp;\
 apt-get install libboost-all-dev &amp;&amp;\
 apt-get install libclang-dev &amp;&amp;\
 apt-get install cmake
</code></pre>
<p>Navigate to the folder containing the Fe source code.</p>
<pre><code class="language-sh">cd fe
</code></pre>
<p>Now, use Rust to build the Fe binary. To run Fe, you need to build using <code>solc-backend</code>.</p>
<pre><code class="language-sh">cargo build -r --feature solc-backend
</code></pre>
<p>You will now find your Fe binary in <code>/target/release</code>. Check the build with:</p>
<pre><code class="language-sh">./target/release/fe --version
</code></pre>
<p>If everything worked, you should see the Fe version printed to the terminal:</p>
<pre><code class="language-sh">fe 0.24.0
</code></pre>
<p>You can run the built-in tests using:</p>
<pre><code class="language-sh">cargo test --workspace --features solc-backend
</code></pre>
<h2 id="editor-support--syntax-highlighting"><a class="header" href="#editor-support--syntax-highlighting">Editor support &amp; Syntax highlighting</a></h2>
<p>Fe is a new language and editor support is still in its early days. However, basic syntax highlighting is available for Visual Studio Code via this <a href="https://marketplace.visualstudio.com/items?itemName=fe-lang.code-ve">VS Code extension</a>.</p>
<p>In Visual Studio Code open the extension sidebar (Ctrl-Shift-P / Cmd-Shift-P, then &quot;Install Extension&quot;) and search for <code>fe-lang.code-ve</code>. Click on the extension and then click on the <code>Install</code> button.</p>
<p>We are currently working on a Language Server Protocol (LSP), which in the future will enable more advanced editor features such as code completion, go-to definition and refactoring.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fe-projects"><a class="header" href="#fe-projects">Fe projects</a></h1>
<p>A project is a collection of files containing Fe code and configuration data. Often, smart contract development can become too complex to contain all the necessary code inside a single file. In these cases, it is useful to organize your work into multiple files and directories. This allows you to group thematically linked code and selectively import the code you need when you need it.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>You can start a project using the <code>new</code> subcommand:</p>
<p><code>$ fe new &lt;my_project&gt;</code></p>
<p>This will generate a template project containing the following:</p>
<ul>
<li>A <code>src</code> directory containing two .fe files.</li>
<li>A <code>fe.toml</code> manifest with basic project info and some local project imports.</li>
</ul>
<h2 id="manifest"><a class="header" href="#manifest">Manifest</a></h2>
<p>The <code>fe.toml</code> file is known as a manifest. The manifest is written in <a href="https://toml.io/">TOML</a> format. The purpose of this file is to provide all the metadata that is required for the project to compile. The file begins with definitions for the project name and version, then the project dependencies are listed under a heading <code>[dependencies]</code>. Dependencies are files in the local filesystem that are required for your project to run.</p>
<p>For example:</p>
<pre><code class="language-toml">name=&quot;my-project&quot;
version = &quot;1.0&quot;

[dependencies]
dependency_1 = &quot;../lib&quot;
</code></pre>
<p>You can also specify which version of a particular dependency you want to use, using curly braces:</p>
<pre><code class="language-toml">name=&quot;my-project&quot;
version = &quot;1.0&quot;

[dependencies]
dependency_1 = {path = &quot;../lib&quot;, version = &quot;1.0&quot;}
</code></pre>
<h2 id="project-modes"><a class="header" href="#project-modes">Project modes</a></h2>
<p>There are two project modes: <code>main</code> and <code>lib</code>. </p>
<p>Main projects can import libraries and have code output. </p>
<p>Libraries on the other hand cannot import main projects and do not have code outputs. Their purpose is to be imported into other projects.</p>
<p>The mode of a project is determined automatically by the presence of either <code>src/main.fe</code> or  <code>src/lib.fe</code>.</p>
<h2 id="importing"><a class="header" href="#importing">Importing</a></h2>
<p>You can import code from external files with the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use utils::get_42
<span class="boring">}</span></code></pre></pre>
<p>This will import the <code>get_42</code> function from the file <code>utils.fe</code>.</p>
<p>You can also import using a custom name/alias:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use utils::get_42 as get_42
<span class="boring">}</span></code></pre></pre>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>The templates created using <code>fe new</code> include a simple test demonstrating the test syntax.</p>
<p>To write a unit test, create a function with a name beginning with <code>test_</code>. The function should instantiate your contract and call the contract function you want to test. You can use <code>assert</code> to check that the returned value matches an expected value.</p>
<p>For example, to test the <code>say_hello</code> function on <code>Contract</code> which is expected to return the string <code>&quot;hello&quot;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_contract(mut ctx: Context) {
    let contract: Contract = Contract.create(ctx, 0)
    assert main.say_hello() == &quot;hello&quot;
}
<span class="boring">}</span></code></pre></pre>
<p>You can run all the tests in a project by running the following command:</p>
<pre><code class="language-sh">fe test &lt;project-root&gt;
</code></pre>
<p>You will receive test results directly to the console.</p>
<h2 id="running-your-project"><a class="header" href="#running-your-project">Running your project</a></h2>
<p>Once you have created a project, you can run the usual Fe CLI subcommands against the project path.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>Welcome to the Tutorials section. We will be adding walkthrough guides for example Fe projects here!</p>
<p>For now, you can get started with: </p>
<ul>
<li><a href="user-guide/tutorials/auction.html">Open auction</a></li>
</ul>
<p>Watch this space for more tutorials coming soon!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auction-contract"><a class="header" href="#auction-contract">Auction contract</a></h1>
<p>This tutorial aims to implement a simple auction contract in Fe. Along the way you will learn some foundational Fe concepts.</p>
<p>An open auction is one where prices are determined in real-time by live bidding. The winner is the participant who has made the highest bid at the time the auction ends.</p>
<h2 id="the-auction-rules"><a class="header" href="#the-auction-rules">The auction rules</a></h2>
<p>To run an open auction, you need an item for sale, a seller, a pool of buyers and a deadline after which no more bids will be recognized. In this tutorial we will not have an item per se, the buyers are simply bidding to win! The highest bidder is provably crowned the winner, and the value of their bid is passed to the beneficiary. Bidders can also withdraw their bids at any time.</p>
<h2 id="get-started-1"><a class="header" href="#get-started-1">Get Started</a></h2>
<p>To follow this guide you should have Fe installed on your computer. If you haven't installed Fe yet, follow the instructions on the <a href="user-guide/tutorials/../installation.html">Installation</a> page.</p>
<p>With Fe installed, you can create a project folder, <code>auction</code> that will act as your project root. In that folder, create an empty file called <code>auction.fe</code>.</p>
<p>Now you are ready to start coding in Fe!</p>
<p>You will also need <a href="https://getfoundry.sh">Foundry</a> installed to follow the deployment instructions in this guide - you can use your alternative tooling for this if you prefer.</p>
<h2 id="writing-the-contract"><a class="header" href="#writing-the-contract">Writing the Contract</a></h2>
<p>You can see the entire contract <a href="user-guide/tutorials/../example_contracts/auction_contract.html">here</a>. You can refer back to this at any time to check implementation details.</p>
<h3 id="defining-the-contract-and-initializing-variables"><a class="header" href="#defining-the-contract-and-initializing-variables">Defining the <code>Contract</code> and initializing variables</a></h3>
<p>A contract in Fe is defined using the <code>contract</code> keyword. A contract requires a constructor function to initialize any state variables used by the contract. If no constructor is defined, Fe will add a default with no state variables. The skeleton of the contract can look as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>contract Auction {
    pub fn __init__() {}
}
<span class="boring">}</span></code></pre></pre>
<p>To run the auction you will need several state variables, some of which can be initialized at the time the contract is instantiated.
You will need to track the address of the beneficiary so you know who to pay out to. You will also need to keep track of the highest bidder, and the amount they have bid. You will also need to keep track of how much each specific address has sent into the contract, so you can refund them the right amount if they decide to withdraw. You will also need a flag that tracks whether or not the auction has ended. The following list of variables will suffice:</p>
<pre><code class="language-sh">auction_end_time: u256
beneficiary: address
highest_bidder: address
highest_bid: u256
pending_returns: Map&lt;address, u256&gt;
ended: bool
</code></pre>
<p>Notice that variables are named using snake case (lower case, underscore separated, <code>like_this</code>). 
<a href="user-guide/tutorials/../../spec/type_system/types/address.html">Addresses</a> have their own type in Fe - it represents 20 hex-encoded bytes as per the Ethereum specification.</p>
<p>The variables that expect numbers are given the <code>u256</code> type. This is an unsigned integer of length 256 bits. There are other <a href="user-guide/tutorials/../../spec/type_system/types/numeric.html">choices for integers</a> too, with both signed and unsigned integers between 8 and 256 bits in length.</p>
<p>The <code>ended</code> variable will be used to check whether the auction is live or not. If it has finished <code>ended</code> will be set to <code>true</code>. There are only two possible states for this, so it makes sense to declare it as a <code>bool</code> - i.e. true/false.</p>
<p>The <code>pending_returns</code> variable is a mapping between N keys and N values, with user addresses as the keys and their bids as values. For this, a <code>Map</code> type is used. In Fe, you define the types for the key and value in the Map definition - in this case, it is <code>Map&lt;address, u256&gt;</code>. Keys can be any <code>numeric</code> type, <code>address</code>, <code>boolean</code> or <code>unit</code>.</p>
<p>Now you should decide which of these variables will have values that are known at the time the contract is instantiated. It makes sense to set the <code>beneficiary</code> right away, so you can add that to the constructor arguments.</p>
<p>The other thing to consider here is <em>how</em> the contract will keep track of time. On its own, the contract has no concept of time. However, the contract does have access to the current block timestamp which is measured in seconds since the Unix epoch (Jan 1st 1970). This can be used to measure the time elapsed in a smart contract. In this contract, you can use this concept to set a deadline on the auction. By passing a length of time in seconds to the constructor, you can then add that value to the current block timestamp and create a deadline for bidding to end. Therefore, you should add a <code>bidding_time</code> argument to the constructor. Its type can be <code>u256</code>.</p>
<p>When you have implemented all this, your contract should look like this:</p>
<pre><code class="language-fe">contract Auction {
    // states
    auction_end_time: u256
    beneficiary: address
    highest_bidder: address
    highest_bid: u256
    pending_returns: Map&lt;address, u256&gt;
    ended: bool

    // constructor
    pub fn __init__(mut self, ctx: Context, bidding_time: u256, beneficiary_addr: address) {
        self.beneficiary = beneficiary_addr
        self.auction_end_time = ctx.block_timestamp() + bidding_time
    }
}
</code></pre>
<p>Notice that the constructor receives values for <code>bidding_time</code> and <code>beneficiary_addr</code> and uses them to initialize the contract's <code>auction_end_time</code> and <code>beneficiary</code> variables.</p>
<p>The other thing to notice about the constructor is that there are two additional arguments passed to the constructor: <code>mut self</code> and <code>ctx: Context</code>.</p>
<h4 id="self"><a class="header" href="#self">self</a></h4>
<p><code>self</code> is used to represent the specific instance of a Contract. It is used to access variables that are owned by that specific instance. This works the same way for Fe contracts as for, e.g. 'self' in the context of classes in Python, or <code>this</code> in Javascript.</p>
<p>Here, you are not only using <code>self</code> but you are prepending it with <code>mut</code>. <code>mut</code> is a keyword inherited from Rust that indicates that the value can be overwritten - i.e. it is &quot;mutable&quot;. Variables are not mutable by default - this is a safety feature that helps protect developers from unintended changes during runtime. If you do not make <code>self</code> mutable, then you will not be able to update the values it contains.</p>
<h4 id="context"><a class="header" href="#context">Context</a></h4>
<p>Context is used to gate access to certain features including emitting logs, creating contracts, reading messages and transferring ETH. It is conventional to name the context object <code>ctx</code>. The <code>Context</code> object needs to be passed as the <em>first</em> parameter to a function unless the function also takes <code>self</code>, in which case the <code>Context</code> object should be passed as the second parameter. <code>Context</code> must be explicitly made mutable if it will invoke functions that changes the blockchain data, whereas an immutable reference to <code>Context</code> can be used where read-only access to the blockchain is needed.</p>
<p>Read more on <a href="https://github.com/ethereum/fe/issues/558">Context in Fe</a></p>
<p>In Fe contracts <code>ctx</code> is where you can find transaction data such as <code>msg.sender</code>, <code>msg.value</code>, <code>block.timestamp</code> etc.</p>
<h3 id="bidding"><a class="header" href="#bidding">Bidding</a></h3>
<p>Now that you have your contract constructor and state variables, you can implement some logic for receiving bids. To do this, you will create a method called <code>bid</code>. To handle a bid, you will first need to determine whether the auction is still open. If it has closed then the bid should revert. If the auction is open you need to record the address of the bidder and the amount and determine whether their bid was the highest. If their bid is highest, then their address should be assigned to the <code>highest_bidder</code> variable and the amount they sent recorded in the <code>highest_bid</code> variable. </p>
<p>This logic can be implemented as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn bid(mut self, mut ctx: Context) {
    if ctx.block_timestamp() &gt; self.auction_end_time {
        revert AuctionAlreadyEnded()
    }
    if ctx.msg_value() &lt;= self.highest_bid {
        revert BidNotHighEnough(highest_bid: self.highest_bid)
    }
    if self.highest_bid != 0 {
        self.pending_returns[self.highest_bidder] += self.highest_bid
    }
    self.highest_bidder = ctx.msg_sender()
    self.highest_bid = ctx.msg_value()

    ctx.emit(HighestBidIncreased(bidder: ctx.msg_sender(), amount: ctx.msg_value()))
}
<span class="boring">}</span></code></pre></pre>
<p>The method first checks that the current block timestamp is not later than the contract's <code>aution_end_time</code> variable. If it <em>is</em> later, then the contract reverts. This is triggered using the <a href="user-guide/tutorials/../../spec/statements/revert.html"><code>revert</code></a> keyword. The <code>revert</code> can accept a struct that becomes encoded as <a href="https://github.com/ethereum/EIPs/issues/838">revert data</a>. Here you can just revert without any arguments. Add the following definition somewhere in <code>Auction.fe</code> outside the main contract definition:</p>
<pre><code class="language-fe">struct AuctionAlreadyEnded {
}
</code></pre>
<p>The next check is whether the incoming bid exceeds the current highest bid. If not, the bid has failed and it may as well revert. We can repeat the same logic as for <code>AuctionAlreadyEnded</code>. We can also report the current highest bid in the revert message to help the user reprice if they want to. Add the following to <code>auction.fe</code>:</p>
<pre><code class="language-fe">struct BidNotHighEnough {
    pub highest_bid: u256
}
</code></pre>
<blockquote>
<p>Notice that the value being checked is <code>msg.value</code> which is included in the <code>ctx</code> object. <code>ctx</code> is where you can access incoming transaction data.</p>
</blockquote>
<p>Next, if the incoming transaction <em>is</em> the highest bid, you need to track how much the sender should receive as a payout if their bid ends up being exceeded by another user (i.e. if they get outbid, they get their ETH back). To do this, you add a key-value pair to the <code>pending_returns</code> mapping, with the user address as the key and the transaction amount as the value. Both of these come from <code>ctx</code> in the form of <code>msg.sender</code> and <code>msg.value</code>.</p>
<p>Finally, if the incoming bid <em>is</em> the highest, you can emit an event. Events are useful because they provide a cheap way to return data from a  contract as they use logs instead of contract storage. Unlike other smart contract languages, there is no <code>emit</code> keyword or <code>Event</code> type. Instead, you trigger an event by calling the <code>emit</code> method on the <code>ctx</code> object. You can pass this method a struct that defines the emitted message. You can add the following struct for this event:</p>
<pre><code class="language-fe">struct HighestBidIncreased {
    #indexed
    pub bidder: address
    pub amount: u256
}
</code></pre>
<p>You have now implemented all the logic to handle a bid!</p>
<h3 id="withdrawing"><a class="header" href="#withdrawing">Withdrawing</a></h3>
<p>A previous high-bidder will want to retrieve their ETH from the contract so they can either walk away or bid again. You therefore need to create a <code>withdraw</code> method that the user can call. The function will lookup the user address in <code>pending_returns</code>. If there is a non-zero value associated with the user's address, the contract should send that amount back to the sender's address. It is important to first update the value in <code>pending_returns</code> and <em>then</em> send the ETH to the user, otherwise you are exposing a <a href="https://www.certik.com/resources/blog/3K7ZUAKpOr1GW75J2i0VHh-what-is-a-reentracy-attack">re-entrancy</a> vulnerability (where a user can repeatedly call the contract and receive the ETH multiple times).</p>
<p>Add the following to the contract to implement the <code>withdraw</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn withdraw(mut self, mut ctx: Context) -&gt; bool {
    let amount: u256 = self.pending_returns[ctx.msg_sender()]

    if amount &gt; 0 {
        self.pending_returns[ctx.msg_sender()] = 0
        ctx.send_value(to: ctx.msg_sender(), wei: amount)
    }
    return true
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong> that in this case <code>mut</code> is used with <code>ctx</code> because <code>send_value</code> is making changes to the blockchain (it is moving ETH from one address to another).</p>
</blockquote>
<h3 id="end-the-auction"><a class="header" href="#end-the-auction">End the auction</a></h3>
<p>Finally, you need to add a way to end the auction. This will check whether the bidding period is over, and if it is, automatically trigger the payment to the beneficiary and emit the address of the winner in an event. </p>
<p>First, check the auction is not still live - if the auction is live you cannot end it early. If an attempt to end the auction early is made, it should revert using a <code>AuctionNotYetEnded</code> struct, which can look as follows:</p>
<pre><code class="language-fe">struct AuctionNotYetEnded {
}
</code></pre>
<p>You should also check whether the auction was <em>already</em> ended by a previous valid call to this method. In this case, revert with a <code>AuctionEndAlreadyCalled</code> struct:</p>
<pre><code class="language-fe">struct AuctionEndAlreadyCalled {}
</code></pre>
<p>If the auction is still live, you can end it. First set <code>self.ended</code> to <code>true</code> to update the contract state. Then emit the event using <code>ctx.emit()</code>. Then, send the ETH to the beneficiary. Again, the order is important - you should always send value last to protect against re-entrancy.
Your method can look as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn action_end(mut self, mut ctx: Context) {
    if ctx.block_timestamp() &lt;= self.auction_end_time {
        revert AuctionNotYetEnded()
    }
    if self.ended {
        revert AuctionEndAlreadyCalled()
    }
    self.ended = true
    ctx.emit(AuctionEnded(winner: self.highest_bidder, amount: self.highest_bid))

    ctx.send_value(to: self.beneficiary, wei: self.highest_bid)
}
<span class="boring">}</span></code></pre></pre>
<p>Congratulations! You just wrote an open auction contract in Fe!</p>
<h2 id="view-functions"><a class="header" href="#view-functions">View functions</a></h2>
<p>To help test the contract without having to decode transaction logs, you can add some simple functions to the contract that simply report the current values for some key state variables (specifically, <code>highest_bidder</code>, <code>highest_bid</code> and <code>ended</code>). This will allow a user to use <code>eth_call</code> to query these values in the contract. <code>eth_call</code> is used for functions that do not update the state of the blockchain and costs no gas because the queries can be performed on local data.</p>
<p>You can add the following functions to the contract:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn check_highest_bidder(self) -&gt; address {
    return self.highest_bidder;
}

pub fn check_highest_bid(self) -&gt; u256 {
    return self.highest_bid;
}

pub fn check_ended(self) -&gt; bool {
    return self.ended;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-deploy-the-contract"><a class="header" href="#build-and-deploy-the-contract">Build and deploy the contract</a></h2>
<p>Your contract is now ready to use! Compile it using</p>
<pre><code class="language-sh">fe build auction.fe
</code></pre>
<p>You will find the contract ABI and bytecode in the newly created <code>outputs</code> directory.</p>
<p>Start a local blockchain to deploy your contract to:</p>
<pre><code class="language-sh">anvil
</code></pre>
<p>There are constructor arguments (<code>bidding_time: u256</code>, <code>beneficiary_addr: address</code>) that have to be added to the contract bytecode so that the contract is instantiated with your desired values. To add constructor arguments you can encode them into bytecode and append them to the contract bytecode.</p>
<p>First, hex encode the value you want to pass to <code>bidding_time</code>. In this case, we will use a value of 10:</p>
<pre><code class="language-sh">cast --to_hex(10)

&gt;&gt; 0xa // this is 10 in hex
</code></pre>
<p>Ethereum addresses are already hex, so there is no further encoding required. The following command will take the constructor function and the hex-encoded arguments and concatenate them into a contiguous hex string and then deploy the contract with the constructor arguments. </p>
<pre><code class="language-sh">cast send --from &lt;your-address&gt; --private-key &lt;your-private-key&gt; --create $(cat output/Auction/Auction.bin) $(cast abi-encode &quot;__init__(uint256,address)&quot; 0xa 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720)
</code></pre>
<p>You will see the contract address reported in your terminal.</p>
<p>Now you can interact with your contract. Start by sending an initial bid, let's say 100 ETH. For contract address <code>0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35</code>:</p>
<pre><code class="language-sh">cast send 0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35 &quot;bid()&quot; --value &quot;100ether&quot; --private-key &lt;your-private-key&gt; --from 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720
</code></pre>
<p>You can check whether this was successful by calling the <code>check_highest_bidder()</code> function:</p>
<pre><code class="language-sh">cast call 0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35 &quot;check_highest_bidder()&quot;
</code></pre>
<p>You will see a response looking similar to:</p>
<pre><code class="language-sh">0x000000000000000000000000a0Ee7A142d267C1f36714E4a8F75612F20a79720
</code></pre>
<p>The characters after the leading zeros are the address for the highest bidder (notice they match the characters after the 0x in the bidding address).</p>
<p>You can do the same to check the highest bid:</p>
<pre><code class="language-sh">cast call 0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35 &quot;check_highest_bid()&quot;
</code></pre>
<p>This returns:</p>
<pre><code class="language-sh">0x0000000000000000000000000000000000000000000000056bc75e2d63100000
</code></pre>
<p>Converting the non-zero characters to binary gives the decimal value of your bid (in wei - divide by 1e18 to get the value in ETH):</p>
<pre><code class="language-sh">cast --to-dec 56bc75e2d63100000

&gt;&gt; 100000000000000000000 // 100 ETH in wei
</code></pre>
<p>Now you can repeat this process, outbidding the initial bid from another address and check the <code>highest_bidder()</code> and <code>highest_bid()</code> to confirm. Do this a few times, then call <code>end_auction()</code> to see the value of the highest bid get transferred to the <code>beneficiary_addr</code>. You can always check the balance of each address using:</p>
<pre><code class="language-sh">cast balance &lt;address&gt;
</code></pre>
<p>And check whether the auction open time has expired using</p>
<pre><code class="language-sh">cast &lt;contract-address&gt; &quot;check_ended()&quot;
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Congratulations! You wrote an open auction contract in Fe and deployed it to a local blockchain!</p>
<p>If you are using a local Anvil blockchain, you can use the ten ephemeral addresses created when the network started to simulate a bidding war!</p>
<p>By following this tutorial, you learned:</p>
<ul>
<li>basic Fe types, such as <code>bool</code>, <code>address</code>, <code>map</code> and <code>u256</code></li>
<li>basic Fe styles, such as snake case for variable names</li>
<li>how to create a <code>contract</code> with a constructor</li>
<li>how to <code>revert</code></li>
<li>how to handle state variables</li>
<li>how to avoid reentrancy</li>
<li>how to use <code>ctx</code> to handle transaction data</li>
<li>how to emit events using <code>ctx.emit</code></li>
<li>how to deploy a contract with constructor arguments using Foundry</li>
<li>how to interact with your contract</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-contracts"><a class="header" href="#example-contracts">Example Contracts</a></h1>
<ul>
<li><a href="user-guide/example_contracts/./auction_contract.html">Simple open auction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-fe">// errors
struct AuctionAlreadyEnded {
}

struct AuctionNotYetEnded {
}

struct AuctionEndAlreadyCalled {}

struct BidNotHighEnough {
    pub highest_bid: u256
}

// events
struct HighestBidIncreased {
    #indexed
    pub bidder: address
    pub amount: u256
}

struct AuctionEnded {
    #indexed
    pub winner: address
    pub amount: u256
}

contract Auction {
    // states
    auction_end_time: u256
    beneficiary: address

    highest_bidder: address
    highest_bid: u256

    pending_returns: Map&lt;address, u256&gt;

    ended: bool

    // constructor
    pub fn __init__(mut self, ctx: Context, bidding_time: u256, beneficiary_addr: address) {
        self.beneficiary = beneficiary_addr
        self.auction_end_time = ctx.block_timestamp() + bidding_time
    }

    //method
    pub fn bid(mut self, mut ctx: Context) {
        if ctx.block_timestamp() &gt; self.auction_end_time {
            revert AuctionAlreadyEnded()
        }
        if ctx.msg_value() &lt;= self.highest_bid {
            revert BidNotHighEnough(highest_bid: self.highest_bid)
        }
        if self.highest_bid != 0 {
            self.pending_returns[self.highest_bidder] += self.highest_bid
        }
        self.highest_bidder = ctx.msg_sender()
        self.highest_bid = ctx.msg_value()

        ctx.emit(HighestBidIncreased(bidder: ctx.msg_sender(), amount: ctx.msg_value()))
    }

    pub fn withdraw(mut self, mut ctx: Context) -&gt; bool {
        let amount: u256 = self.pending_returns[ctx.msg_sender()]

        if amount &gt; 0 {
            self.pending_returns[ctx.msg_sender()] = 0
            ctx.send_value(to: ctx.msg_sender(), wei: amount)
        }
        return true
    }

    pub fn auction_end(mut self, mut ctx: Context) {
        if ctx.block_timestamp() &lt;= self.auction_end_time {
            revert AuctionNotYetEnded()
        }
        if self.ended {
            revert AuctionEndAlreadyCalled()
        }
        self.ended = true
        ctx.emit(AuctionEnded(winner: self.highest_bidder, amount: self.highest_bid))

        ctx.send_value(to: self.beneficiary, wei: self.highest_bid)
    }

    pub fn check_highest_bidder(self) -&gt; address {
        return self.highest_bidder;
    }

    pub fn check_highest_bid(self) -&gt; u256 {
        return self.highest_bid;
    }

    pub fn check_ended(self) -&gt; bool {
        return self.ended;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-external-links"><a class="header" href="#useful-external-links">Useful external links</a></h1>
<p>There are not many resources for Fe outside of the official documentation at this time. This section lists useful links to external resources.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=fe-lang.code-ve">VS Code extension</a></li>
<li><a href="https://github.com/fe-lang/Foundry-Fe">Foundry Fe Support</a></li>
</ul>
<h2 id="projects"><a class="header" href="#projects">Projects</a></h2>
<ul>
<li><a href="https://github.com/fe-lang/bountiful/tree/master">Bountiful</a> - Bug bounty platform written in Fe, live on Mainnet</li>
<li><a href="https://github.com/cburgdorf/simple_dao">Simple DAO</a> - A Simple DAO written in Fe - live on Mainnet and Optimism</li>
</ul>
<h3 id="hackathon-projects"><a class="header" href="#hackathon-projects">Hackathon projects</a></h3>
<p>These are community projects written in Fe at various hackathons.</p>
<ul>
<li>
<p><a href="https://github.com/bilgin-kocak/felang-fixedpoint">Fixed-Point Numerical Library</a> - A fixed-point number representation and mathematical operations tailored for Fe. It can be used in financial computations, scientific simulations, and data analysis.</p>
</li>
<li>
<p><a href="https://github.com/0xnonso/p256-verifier-fe">p256verifier</a> - Secp256r1 (a.k.a p256) curve signature verifier which allows for verification of a P256 signature in fe.</p>
</li>
<li>
<p><a href="https://github.com/kevincharm/account_kv_storage_fe">Account Storage with Efficient Sparse Merkle Trees</a> - Efficient Sparse Merkle Trees in Fe! SMTs enable inclusion and exclusion proofs for the entire set of Ethereum addresses.</p>
</li>
<li>
<p><a href="https://github.com/grey220022/Fehackathon">Tic Tac Toe</a> - An implementation of the classic tic tac toe game in Fe with a Python frontend.</p>
</li>
<li>
<p><a href="https://github.com/clemlak/fe-hackathon">Fecret Santa</a> - Fecret Santa is an onchain Secret Santa event based on a &quot;chain&quot;: gift a collectible (ERC721 or ERC1155) to the last Santa and you'll be the next to receive a gift!</p>
</li>
<li>
<p><a href="https://github.com/gin/go-do-it">Go do it</a> - A commitment device to help you achieve your goals.</p>
</li>
<li>
<p><a href="https://github.com/kevincharm/powerbald-fe">Powerbald</a> - On chain lottery written in Fe</p>
</li>
<li>
<p><a href="https://github.com/dknopik/sspc-flutter-fe">sspc-flutter-fe</a> - Stupid Simple Payment Channel written in Fe</p>
</li>
</ul>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<ul>
<li>
<p><a href="https://github.com/ethereum/fe/tree/master/crates/library/std/src">Fe standard library</a> - The Fe standard library comes bundled with the compiler but it is also a useful example for real world Fe code.</p>
</li>
<li>
<p><a href="https://github.com/cburgdorf/fe-real-world-examples/blob/master/fe_contracts/defi/src/main.fe">Implementing an UniswapV3 trade in Fe</a></p>
</li>
</ul>
<h2 id="blog-posts"><a class="header" href="#blog-posts">Blog posts</a></h2>
<ul>
<li><a href="https://dev.to/filosofiacodigoen/fe-or-solidity-which-is-better-1fdj">Fe or Solidity, which is better?</a> by Ahmed Castro</li>
</ul>
<h2 id="videos"><a class="header" href="#videos">Videos</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=zKxmtbVNscg">Fe or Solidity, which is better?</a> by Ahmed Castro</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=_ODiAW8mq3o">Fe o Solidity, ¬øcu√°l es es mejor?</a> by Ahmed Castro</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>Read how to become a Fe developer.</p>
<ul>
<li><a href="development/build.html">Build &amp; Test</a></li>
<li><a href="development/release.html">Release</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-and-test"><a class="header" href="#build-and-test">Build and test</a></h2>
<p>Please make sure Rust is <a href="https://www.rust-lang.org/learn/get-started">installed</a>.</p>
<p><strong>Basic</strong></p>
<p>The following commands only build the Fe -&gt; Yul compiler components.</p>
<ul>
<li>build the CLI: <code>cargo build</code></li>
<li>test: <code>cargo test --workspace</code></li>
</ul>
<p><strong>Full</strong></p>
<p>The Fe compiler depends on the Solidity compiler for transforming Yul IR to EVM bytecode. We currently use <a href="https://github.com/fe-lang/solc-rust">solc-rust</a> to perform this. In order to compile solc-rust, the following must be installed on your system:</p>
<ul>
<li>cmake</li>
<li>boost(1.65+)</li>
<li>libclang</li>
</ul>
<pre><code class="language-bash">    brew install boost
</code></pre>
<p>Once these have been installed, you may run the full build. This is enabled using the <em>solc-backend</em> feature.</p>
<ul>
<li>build the CLI: <code>cargo build --features solc-backend</code></li>
<li>test: <code>cargo test --workspace --features solc-backend</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="release"><a class="header" href="#release">Release</a></h2>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>Make sure that version follows <a href="https://semver.org/">semver</a> rules e.g (<code>0.23.0</code>).</p>
<h3 id="generate-release-notes"><a class="header" href="#generate-release-notes">Generate Release Notes</a></h3>
<p><strong>Prerequisite</strong>: Release notes are generated with <a href="https://pypi.org/project/towncrier/">towncrier</a>. Ensure to have <code>towncrier</code> installed and the command is available.</p>
<p>Run <code>make notes version=&lt;version&gt;</code> where <code>&lt;version&gt;</code> is the version we are generating the release notes for e.g. <code>0.23.0</code>.</p>
<p>Example:</p>
<pre><code>make notes version=0.23.0
</code></pre>
<p>Examine the generated release notes and if needed perform and commit any manual changes.</p>
<h3 id="generate-the-release"><a class="header" href="#generate-the-release">Generate the release</a></h3>
<p>Run <code>make release version=&lt;version&gt;</code>.</p>
<p>Example:</p>
<pre><code>make release version=0.23.0
</code></pre>
<p>This will also run the tests again as the last step because some of them may need to be adjusted because of the changed version number.</p>
<h3 id="tag-and-push-the-release"><a class="header" href="#tag-and-push-the-release">Tag and push the release</a></h3>
<p><strong>Prerequisite</strong>: Make sure the central repository is configured as <code>upstream</code>, <strong>not</strong> <code>origin</code>.</p>
<p>After the tests are adjusted run <code>make push-tag</code> to create the tag and push it to Github.</p>
<h3 id="manually-edit-the-release-on-github"><a class="header" href="#manually-edit-the-release-on-github">Manually edit the release on GitHub</a></h3>
<p>Running the previous command will push a new tag to Github and cause the CI to create a <a href="https://github.com/ethereum/fe/releases">release</a> with the Fe binaries attached. We may want to edit the release afterwards to put in some verbiage about the release.</p>
<h2 id="updating-docs--website"><a class="header" href="#updating-docs--website">Updating Docs &amp; Website</a></h2>
<p>A release of a new Fe compiler should usually go hand in hand with updating the website and documentation. For one, the front page of <a href="https://fe-lang.org">fe-lang.org</a> links to the download of the compiler but won't automatically pick up the latest release without a fresh deployment. Furthermore, if code examples and other docs needed to be updated along with compiler changes, these updates are also only reflected online when the site gets redeployed. This is especially problematic since our docs do currently not have a version switcher to view documentation for different compiler versions (<a href="https://github.com/ethereum/fe/issues/543">See GitHub issue #543</a>).</p>
<h3 id="preview-the-sites-locally"><a class="header" href="#preview-the-sites-locally">Preview the sites locally</a></h3>
<p>Run <code>make serve-website</code> and visit http://0.0.0.0:8000 to preview it locally. Ensure the front page displays the correct compiler version for download and that the docs render correctly.</p>
<h3 id="deploy-website--docs"><a class="header" href="#deploy-website--docs">Deploy website &amp; docs</a></h3>
<p><strong>Prerequisite</strong>: Make sure the central repository is configured as <code>upstream</code>, <strong>not</strong> <code>origin</code>.</p>
<p>Run <code>make deploy-website</code> and validate that <a href="https://fe-lang.org">fe-lang.org</a> renders the updated sites (Can take up to a few minutes).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fe-standard-library"><a class="header" href="#fe-standard-library">Fe Standard Library</a></h1>
<p>The standard library includes commonly used algorithms and data structures that come bundled as part of the language.</p>
<ul>
<li><a href="std/./precompiles.html">Precompiles</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="precompiles"><a class="header" href="#precompiles">Precompiles</a></h1>
<p>Precompiles are EVM functions that are prebuilt and optimized as part of the Fe standard library. There are currently nine precompiles available in Fe. The first four precompiles were defined in the original <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a> (<code>ec_recover</code>, <code>SHA2_256</code>, <code>ripemd_160</code>, <code>identity)</code>. Four more were added during the <a href="https://ethereum.org/en/history/#byzantium">Byzantium fork</a> (<code>mod_exp</code>, <code>ec_add</code>, <code>ec_mul</code> and <code>ec_pairing</code>). A final precompile, <code>blake2f</code> was added in <a href="https://github.com/ethereum/EIPs/issues/152">EIP-152</a> during the <a href="https://ethereum.org/en/history/#istanbul">Istanbul fork</a>.</p>
<p>The nine precompiles available in the Fe standard library are:</p>
<ul>
<li><a href="std/precompiles.html#ecrecover"><code>ec_recover</code></a></li>
<li><a href="std/precompiles.html#sha2256"><code>SHA2 256</code></a></li>
<li><a href="std/precompiles.html#Ripemd160"><code>ripemd160</code></a></li>
<li><a href="std/precompiles.html#identity"><code>identity</code></a></li>
<li><a href="std/precompiles.html#modexp"><code>mod_exp</code></a></li>
<li><a href="std/precompiles.html#ecadd"><code>ec_add</code></a></li>
<li><a href="std/precompiles.html#ecmul"><code>ec_mul</code></a></li>
<li><a href="std/precompiles.html#ecpairing"><code>ec_pairing</code></a></li>
<li><a href="std/precompiles.html#blake2f"><code>blake2f</code></a></li>
</ul>
<p>These precompiles are imported as follows:</p>
<pre><code class="language-fe ignore ignore">use std::precompiles
</code></pre>
<h2 id="ec_recover"><a class="header" href="#ec_recover"><code>ec_recover</code></a></h2>
<p><code>ec_recover</code> is a cryptographic function that retrieves a signer's address from a signed message. It is the fundamental operation used for verifying signatures in Ethereum. Ethereum uses the  Elliptic Curve Digital Signature Algorithm (ECDSA) for verifying signatures. This algorithm uses two parameters, <code>r</code> and <code>s</code>. Ethereum's implementation also uses an additional 'recovery identifier' parameter, <code>v</code>, which is used to identify the correct elliptic curve point from those that can be calculated from <code>r</code> and <code>s</code> alone.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<ul>
<li><code>hash</code>: the hash of the signed message, <code>u256</code></li>
<li><code>v</code>: the recovery identifier, a number in the range 27-30, <code>u256</code></li>
<li><code>r</code>: elliptic curve parameter, <code>u256</code></li>
<li><code>s</code>: elliptic curve parameter, <code>u256</code></li>
</ul>
<h3 id="returns"><a class="header" href="#returns">Returns</a></h3>
<p><code>ec_recover</code> returns an address.</p>
<h3 id="function-signature"><a class="header" href="#function-signature">Function signature</a></h3>
<pre><code class="language-fe ignore ignore">pub fn ec_recover(hash: u256, v: u256, r: u256, s: u256) -&gt; address
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-fe ignore ignore">let result: address = precompiles::ec_recover(
    hash: 0x456e9aea5e197a1f1af7a3e85a3212fa4049a3ba34c2289b4c860fc0b0c64ef3,
    v: 28,
    r: 0x9242685bf161793cc25603c231bc2f568eb630ea16aa137d2664ac8038825608,
    s: 0x4f8ae3bd7535248d0bd448298cc2e2071e56992d0774dc340c368ae950852ada
)
</code></pre>
<h2 id="sha2_256"><a class="header" href="#sha2_256"><code>SHA2_256</code></a></h2>
<p><code>SHA2_256</code> is a hash function. a hash function generates a unique string of characters of fixed length from arbitrary input data.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<ul>
<li><code>buf</code>: a sequence of bytes to hash, <code>MemoryBuffer</code></li>
</ul>
<h3 id="returns-1"><a class="header" href="#returns-1">Returns</a></h3>
<p><code>SHA2_256</code> returns a hash as a <code>u256</code></p>
<h3 id="function-signature-1"><a class="header" href="#function-signature-1">Function signature</a></h3>
<pre><code class="language-fe ignore ignore">pub fn sha2_256(buf input_buf: MemoryBuffer) -&gt; u256
</code></pre>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-fe ignore">let buf: MemoryBuffer = MemoryBuffer::from_u8(value: 0xff)
let result: u256 = precompiles::sha2_256(buf)
</code></pre>
<h2 id="ripemd_160"><a class="header" href="#ripemd_160"><code>ripemd_160</code></a></h2>
<p><code>ripemd_160</code> is a hash function that is rarely used in Ethereum, but is included in many crypto libraries as it is used in Bitcoin core.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<ul>
<li><code>input_buf</code>: a sequence of bytes to hash, <code>MemoryBuffer</code></li>
</ul>
<h3 id="returns-2"><a class="header" href="#returns-2">Returns</a></h3>
<p><code>ripemd_160</code> returns a hash as a <code>u256</code></p>
<h3 id="function-signature-2"><a class="header" href="#function-signature-2">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn ripemd_160(buf input_buf: MemoryBuffer) -&gt; u256

</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-fe ignore">let buf: MemoryBuffer = MemoryBuffer::from_u8(value: 0xff)
let result: u256 = precompiles::ripemd_160(buf)
</code></pre>
<h2 id="identity"><a class="header" href="#identity"><code>identity</code></a></h2>
<p><code>identity</code> is a function that simply echoes the input of the function as its output. This can be used for efficient data copying.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<ul>
<li><code>input_buf</code>: a sequence of bytes to hash, <code>MemoryBuffer</code></li>
</ul>
<h3 id="returns-3"><a class="header" href="#returns-3">Returns</a></h3>
<p><code>identity</code> returns a sequence of bytes, <code>MemoryBuffer</code></p>
<h3 id="function-signature-3"><a class="header" href="#function-signature-3">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn identity(buf input_buf: MemoryBuffer) -&gt; MemoryBuffer

</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-fe ignore">let buf: MemoryBuffer = MemoryBuffer::from_u8(value: 0x42)
let mut result: MemoryBufferReader = precompiles::identity(buf).reader()
</code></pre>
<h2 id="mod_exp"><a class="header" href="#mod_exp"><code>mod_exp</code></a></h2>
<p><code>mod_exp</code> is a modular exponentiation function required for elliptic curve operations.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<ul>
<li>b: <code>MemoryBuffer</code>: the base (i.e. the number being raised to a power), <code>MemoryBuffer</code></li>
<li>e: <code>MemoryBuffer</code>: the exponent (i.e. the power <code>b</code> is raised to), <code>MemoryBuffer</code></li>
<li>m: <code>MemoryBuffer</code>: the modulus, <code>MemoryBuffer</code></li>
<li>b_size: <code>u256</code>: the length of <code>b</code> in bytes, <code>u256</code></li>
<li>e_size: <code>u256</code>: the length of <code>e</code> in bytes, <code>u256</code></li>
<li>m_size: <code>u256</code>: then length of <code>m</code> in bytes, <code>u256</code></li>
</ul>
<h3 id="returns-4"><a class="header" href="#returns-4">Returns</a></h3>
<p><code>mod_exp</code> returns a sequence of bytes, <code>MemoryBuffer</code></p>
<h3 id="function-signature-4"><a class="header" href="#function-signature-4">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn mod_exp(
    b_size: u256,
    e_size: u256,
    m_size: u256,
    b: MemoryBuffer,
    e: MemoryBuffer,
    m: MemoryBuffer,
) -&gt; MemoryBuffer

</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-fe ignore">let mut result: MemoryBufferReader = precompiles::mod_exp(
    b_size: 1,
    e_size: 1,
    m_size: 1,
    b: MemoryBuffer::from_u8(value: 8),
    e: MemoryBuffer::from_u8(value: 9),
    m: MemoryBuffer::from_u8(value: 10),
).reader()
</code></pre>
<h2 id="ec_add"><a class="header" href="#ec_add"><code>ec_add</code></a></h2>
<p><code>ec_add</code> does point addition on elliptic curves.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<ul>
<li><code>x1</code>: x-coordinate 1, <code>u256</code></li>
<li><code>y1</code>: y coordinate 1, <code>u256</code></li>
<li><code>x2</code>: x coordinate 2, <code>u256</code></li>
<li><code>y2</code>: y coordinate 2, <code>u256</code></li>
</ul>
<h3 id="function-signature-5"><a class="header" href="#function-signature-5">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn ec_add(x1: u256, y1: u256, x2: u256, y2: u256)-&gt; (u256,u256)
</code></pre>
<h3 id="returns-5"><a class="header" href="#returns-5">Returns</a></h3>
<p><code>ec_add</code> returns a tuple of <code>u256</code>, <code>(u256, u256)</code>.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-fe ignore">let (x, y): (u256, u256) = precompiles::ec_add(x1: 1, y1: 2, x2: 1, y2: 2)
</code></pre>
<h2 id="ec_mul"><a class="header" href="#ec_mul"><code>ec_mul</code></a></h2>
<p><code>ec_mul</code> is for multiplying elliptic curve points.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<ul>
<li><code>x</code>: x-coordinate, <code>u256</code></li>
<li><code>y</code>: y coordinate, <code>u256</code></li>
<li><code>s</code>: multiplier, <code>u256</code></li>
</ul>
<h3 id="function-signature-6"><a class="header" href="#function-signature-6">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn ec_mul(x: u256, y: u256, s: u256)-&gt; (u256,u256)
</code></pre>
<h3 id="returns-6"><a class="header" href="#returns-6">Returns</a></h3>
<p><code>ec_mul</code> returns a tuple of <code>u256</code>, <code>(u256, u256)</code>.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-fe ignore">let (x, y): (u256, u256) = precompiles::ec_mul(
    x: 1,
    y: 2,
    s: 2
)
</code></pre>
<h2 id="ec_pairing"><a class="header" href="#ec_pairing"><code>ec_pairing</code></a></h2>
<p><code>ec_pairing</code> does elliptic curve pairing - a form of encrypted multiplication.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<ul>
<li><code>input_buf</code>: sequence of bytes representing the result of the elliptic curve operation <code>(G1 * G2) ^ k</code>, as <code>MemoryBuffer</code></li>
</ul>
<h3 id="returns-7"><a class="header" href="#returns-7">Returns</a></h3>
<p><code>ec_pairing</code> returns a <code>bool</code> indicating whether the pairing is satisfied (<code>true</code>) or not (<code>false</code>).</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-fe ignore">    let mut input_buf: MemoryBuffer = MemoryBuffer::new(len: 384)
    let mut writer: MemoryBufferWriter = buf.writer()

    writer.write(value: 0x2cf44499d5d27bb186308b7af7af02ac5bc9eeb6a3d147c186b21fb1b76e18da)
    writer.write(value: 0x2c0f001f52110ccfe69108924926e45f0b0c868df0e7bde1fe16d3242dc715f6)
    writer.write(value: 0x1fb19bb476f6b9e44e2a32234da8212f61cd63919354bc06aef31e3cfaff3ebc)
    writer.write(value: 0x22606845ff186793914e03e21df544c34ffe2f2f3504de8a79d9159eca2d98d9)
    writer.write(value: 0x2bd368e28381e8eccb5fa81fc26cf3f048eea9abfdd85d7ed3ab3698d63e4f90)
    writer.write(value: 0x2fe02e47887507adf0ff1743cbac6ba291e66f59be6bd763950bb16041a0a85e)
    writer.write(value: 0x0000000000000000000000000000000000000000000000000000000000000001)
    writer.write(value: 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd45)
    writer.write(value: 0x1971ff0471b09fa93caaf13cbf443c1aede09cc4328f5a62aad45f40ec133eb4)
    writer.write(value: 0x091058a3141822985733cbdddfed0fd8d6c104e9e9eff40bf5abfef9ab163bc7)
    writer.write(value: 0x2a23af9a5ce2ba2796c1f4e453a370eb0af8c212d9dc9acd8fc02c2e907baea2)
    writer.write(value: 0x23a8eb0b0996252cb548a4487da97b02422ebc0e834613f954de6c7e0afdc1fc)

    assert precompiles::ec_pairing(buf)
}
</code></pre>
<h2 id="blake_2f"><a class="header" href="#blake_2f"><code>blake_2f</code></a></h2>
<p><code>blake_2f</code> is a compression algorithm for the cryptographic hash function <code>BLAKE2b</code>. It takes as an argument the state vector <code>h</code>, message block vector <code>m</code>, offset counter <code>t</code>, final block indicator flag <code>f</code>, and number of rounds <code>rounds</code>. The state vector provided as the first parameter is modified by the function.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<ul>
<li><code>h</code>: the state vector, <code>Array&lt;u64, 8&gt;</code></li>
<li><code>m</code>: message block vector, <code>Array&lt;u64, 16&gt;</code></li>
<li><code>t</code>: offset counter, <code>Array&lt;u64, 2&gt;</code></li>
<li><code>f</code>: bool</li>
<li><code>rounds</code>: number of rounds of mixing, <code>u32</code></li>
</ul>
<h3 id="returns-8"><a class="header" href="#returns-8">Returns</a></h3>
<p><code>blake_2f</code> returns a modified state vector, <code>Array&lt;u64, 8&gt;</code></p>
<h3 id="function-signature-7"><a class="header" href="#function-signature-7">Function signature</a></h3>
<pre><code class="language-fe ignore">pub fn blake_2f(rounds: u32, h: Array&lt;u64, 8&gt;, m: Array&lt;u64, 16&gt;, t: Array&lt;u64, 2&gt;, f: bool) -&gt;  Array&lt;u64, 8&gt;
</code></pre>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-fe ignore">let result: Array&lt;u64, 8&gt; = precompiles::blake_2f(
    rounds: 12,
    h: [
        0x48c9bdf267e6096a,
        0x3ba7ca8485ae67bb,
        0x2bf894fe72f36e3c,
        0xf1361d5f3af54fa5,
        0xd182e6ad7f520e51,
        0x1f6c3e2b8c68059b,
        0x6bbd41fbabd9831f,
        0x79217e1319cde05b,
    ],
    m: [
        0x6162630000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000,
    ],
    t: [
        0x0300000000000000,
        0x0000000000000000,
    ],
    f: true
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fe-language-specification"><a class="header" href="#fe-language-specification">Fe Language Specification</a></h1>
<div class="warning">
  Warning: This is a work in progress document. It is incomplete and specifications aren't stable yet.
</div>
<ul>
<li><a href="spec/notation.html">Notation</a></li>
<li><a href="spec/lexical_structure/index.html">Lexical Structure</a>
<ul>
<li><a href="spec/lexical_structure/keywords.html">Keywords</a></li>
<li><a href="spec/lexical_structure/identifiers.html">Identifiers</a></li>
<li><a href="spec/lexical_structure/tokens.html">Tokens</a></li>
</ul>
</li>
<li><a href="spec/comments.html">Comments</a></li>
<li><a href="spec/items/index.html">Items</a>
<ul>
<li><a href="spec/items/visibility_and_privacy.html">Visibility and Privacy</a></li>
<li><a href="spec/items/structs.html">Structs</a></li>
<li><a href="spec/items/traits.html">Traits</a></li>
<li><a href="spec/items/enums.html">Enums</a></li>
<li><a href="spec/items/type_aliases.html">Type Aliases</a></li>
<li><a href="spec/items/contracts.html">Contracts</a></li>
<li><a href="spec/items/functions/index.html">Functions</a>
<ul>
<li><a href="spec/items/functions/context.html">Context</a></li>
<li><a href="spec/items/functions/self.html">Self</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="spec/statements/index.html">Statements</a>
<ul>
<li><a href="spec/statements/pragma.html"><code>pragma</code> Statement</a></li>
<li><a href="spec/statements/assign.html">Assignment Statement</a></li>
<li><a href="spec/statements/augassign.html">Augmenting Assignment Statement</a></li>
<li><a href="spec/statements/const.html"><code>const</code> Statement</a></li>
<li><a href="spec/statements/let.html"><code>let</code> Statement</a></li>
<li><a href="spec/statements/revert.html"><code>revert</code> Statement</a></li>
<li><a href="spec/statements/return.html"><code>return</code> Statement</a></li>
<li><a href="spec/statements/if.html"><code>if</code> Statement</a></li>
<li><a href="spec/statements/for.html"><code>for</code> Statement</a></li>
<li><a href="spec/statements/while.html"><code>while</code> Statement</a></li>
<li><a href="spec/statements/break.html"><code>break</code> Statement</a></li>
<li><a href="spec/statements/continue.html"><code>continue</code> Statement</a></li>
<li><a href="spec/statements/assert.html"><code>assert</code> Statement</a></li>
</ul>
</li>
<li><a href="spec/expressions/index.html">Expressions</a>
<ul>
<li><a href="spec/expressions/call.html">Call expressions</a></li>
<li><a href="spec/expressions/tuple.html">Tuple expressions</a></li>
<li><a href="spec/expressions/list.html">List expressions</a></li>
<li><a href="spec/expressions/index.html">Index expressions</a></li>
<li><a href="spec/expressions/attribute.html">Attribute expressions</a></li>
<li><a href="spec/expressions/name.html">Name expressions</a></li>
<li><a href="spec/expressions/literal.html">Literal expressions</a></li>
<li><a href="spec/expressions/arithmetic_operators.html">Arithmetic Operators</a></li>
<li><a href="spec/expressions/comparison_operators.html">Comparison Operators</a></li>
<li><a href="spec/expressions/boolean_operators.html">Boolean Operators</a></li>
<li><a href="spec/expressions/unary_operators.html">Unary Operators</a></li>
</ul>
</li>
<li><a href="spec/type_system/index.html">Type System</a>
<ul>
<li><a href="spec/type_system/types/index.html">Types</a>
<ul>
<li><a href="spec/type_system/types/boolean.html">Boolean Type</a></li>
<li><a href="spec/type_system/types/contract.html">Contract Type</a></li>
<li><a href="spec/type_system/types/numeric.html">Numeric Types</a></li>
<li><a href="spec/type_system/types/tuple.html">Tuple Types</a></li>
<li><a href="spec/type_system/types/array.html">Array Types</a></li>
<li><a href="spec/type_system/types/struct.html">Struct Types</a></li>
<li><a href="spec/type_system/types/enum.html">Enum Types</a></li>
<li><a href="spec/type_system/types/address.html">Address Type</a></li>
<li><a href="spec/type_system/types/map.html">Map Type</a></li>
<li><a href="spec/type_system/types/string.html">String Type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="spec/data_layout/index.html">Data Layout</a>
<ul>
<li><a href="spec/data_layout/stack.html">Stack</a></li>
<li><a href="spec/data_layout/storage/index.html">Storage</a>
<ul>
<li><a href="spec/data_layout/storage/constant_size_values_in_storage.html">Constant size values in storage</a></li>
<li><a href="spec/data_layout/storage/maps_in_storage.html">Maps in storage</a></li>
<li><a href="spec/data_layout/storage/to_mem_function.html"><code>to_mem()</code> function</a></li>
</ul>
</li>
<li><a href="spec/data_layout/memory/index.html">Memory</a>
<ul>
<li><a href="spec/data_layout/memory/sequence_types_in_memory.html">Sequence types in memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>The following notations are used by the <em>Lexer</em> and <em>Syntax</em> grammar snippets:</p>
<div class="table-wrapper"><table><thead><tr><th>Notation</th><th>Examples</th><th>Meaning</th></tr></thead><tbody>
<tr><td>CAPITAL</td><td>KW_IF</td><td>A token produced by the lexer</td></tr>
<tr><td><em>ItalicCamelCase</em></td><td><em>Item</em></td><td>A syntactical production</td></tr>
<tr><td><code>string</code></td><td><code>x</code>, <code>while</code>, <code>*</code></td><td>The exact character(s)</td></tr>
<tr><td>\x</td><td>\n, \r, \t, \0</td><td>The character represented by this escape</td></tr>
<tr><td>x<sup>?</sup></td><td><code>pub</code><sup>?</sup></td><td>An optional item</td></tr>
<tr><td>x<sup>*</sup></td><td><em>OuterAttribute</em><sup>*</sup></td><td>0 or more of x</td></tr>
<tr><td>x<sup>+</sup></td><td><em>MacroMatch</em><sup>+</sup></td><td>1 or more of x</td></tr>
<tr><td>x<sup>a..b</sup></td><td>HEX_DIGIT<sup>1..6</sup></td><td>a to b repetitions of x</td></tr>
<tr><td>|</td><td><code>u8</code> | <code>u16</code>, Block | Item</td><td>Either one or another</td></tr>
<tr><td>[ ]</td><td>[<code>b</code> <code>B</code>]</td><td>Any of the characters listed</td></tr>
<tr><td>[ - ]</td><td>[<code>a</code>-<code>z</code>]</td><td>Any of the characters in the range</td></tr>
<tr><td>~[ ]</td><td>~[<code>b</code> <code>B</code>]</td><td>Any characters, except those listed</td></tr>
<tr><td>~<code>string</code></td><td>~<code>\n</code>, ~<code>*/</code></td><td>Any characters, except this sequence</td></tr>
<tr><td>( )</td><td>(<code>,</code> <em>Parameter</em>)</td><td>Groups items</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-structure"><a class="header" href="#lexical-structure">Lexical Structure</a></h1>
<ul>
<li><a href="spec/lexical_structure/./keywords.html">Keywords</a></li>
<li><a href="spec/lexical_structure/./identifiers.html">Identifiers</a></li>
<li><a href="spec/lexical_structure/./tokens.html">Tokens</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>Fe divides keywords into two categories:</p>
<ul>
<li><a href="spec/lexical_structure/keywords.html#strict-keywords">strict</a></li>
<li><a href="spec/lexical_structure/keywords.html#reserved-keywords">reserved</a></li>
</ul>
<h2 id="strict-keywords"><a class="header" href="#strict-keywords">Strict keywords</a></h2>
<p>These keywords can only be used in their correct contexts. They cannot
be used as the <a href="spec/lexical_structure/./identifiers.html">identifiers</a>.</p>
<blockquote>
<p><strong>Lexer:</strong><br />
KW_AS             : <code>as</code><br />
KW_BREAK          : <code>break</code><br />
KW_CONST          : <code>const</code><br />
KW_CONTINUE       : <code>continue</code><br />
KW_CONST          : <code>contract</code><br />
KW_FN             : <code>fn</code><br />
KW_ELSE           : <code>else</code><br />
KW_ENUM           : <code>enum</code><br />
KW_EVENT          : <code>event</code><br />
KW_FALSE          : <code>false</code><br />
KW_FOR            : <code>for</code><br />
KW_IDX             : <code>idx</code><br />
KW_IF             : <code>if</code><br />
KW_IN             : <code>in</code><br />
KW_LET            : <code>let</code><br />
KW_MATCH          : <code>match</code><br />
KW_MUT            : <code>mut</code><br />
KW_NONPAYABLE     : <code>nonpayable</code><br />
KW_PAYABLE        : <code>payable</code><br />
KW_PUB            : <code>pub</code><br />
KW_RETURN         : <code>return</code><br />
KW_REVERT         : <code>revert</code><br />
KW_SELFVALUE      : <code>self</code><br />
KW_STRUCT         : <code>struct</code><br />
KW_TRUE           : <code>true</code><br />
KW_USE            : <code>use</code><br />
KW_WHILE          : <code>while</code> <br />
KW_ADDRESS        : <code>address</code></p>
</blockquote>
<h2 id="reserved-keywords"><a class="header" href="#reserved-keywords">Reserved keywords</a></h2>
<p>These keywords aren't used yet, but they are reserved for future use. They have
the same restrictions as strict keywords. The reasoning behind this is to make
current programs forward compatible with future versions of Fe by forbidding
them to use these keywords.</p>
<blockquote>
<p><strong>Lexer:</strong><br />
KW_ABSTRACT       : <code>abstract</code><br />
KW_ASYNC          : <code>async</code><br />
KW_AWAIT          : <code>await</code><br />
KW_DO             : <code>do</code><br />
KW_EXTERNAL       : <code>external</code><br />
KW_FINAL          : <code>final</code><br />
KW_IMPL           : <code>impl</code><br />
KW_MACRO          : <code>macro</code><br />
KW_OVERRIDE       : <code>override</code><br />
KW_PURE           : <code>pure</code><br />
KW_SELFTYPE       : <code>Self</code><br />
KW_STATIC         : <code>static</code><br />
KW_SUPER          : <code>super</code><br />
KW_TRAIT          : <code>trait</code><br />
KW_TYPE           : <code>type</code><br />
KW_TYPEOF         : <code>typeof</code><br />
KW_VIEW           : <code>view</code><br />
KW_VIRTUAL        : <code>virtual</code><br />
KW_WHERE          : <code>where</code><br />
KW_YIELD          : <code>yield</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<blockquote>
<p><strong><sup>Lexer:<sup></strong><br />
IDENTIFIER_OR_KEYWORD :<br />
¬†¬† ¬†¬† [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code>]¬†[<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_</code>]<sup>*</sup><br />
¬†¬† | <code>_</code> [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_</code>]<sup>+</sup>
<sub><em>Except a <a href="spec/lexical_structure/keywords.html#strict-keywords">strict</a> or <a href="spec/lexical_structure/keywords.html#reserved-keywords">reserved</a> keyword</em></sub></p>
</blockquote>
<p>An identifier is any nonempty ASCII string of the following form:</p>
<p>Either</p>
<ul>
<li>The first character is a letter.</li>
<li>The remaining characters are alphanumeric or <code>_</code>.</li>
</ul>
<p>Or</p>
<ul>
<li>The first character is <code>_</code>.</li>
<li>The identifier is more than one character. <code>_</code> alone is not an identifier.</li>
<li>The remaining characters are alphanumeric or <code>_</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<h3 id="newline"><a class="header" href="#newline"><code>NEWLINE</code></a></h3>
<p>A token that represents a new line.</p>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>A literal is an expression consisting of a single token, rather than a sequence
of tokens, that immediately and directly denotes the value it evaluates to,
rather than referring to it by name or some other evaluation rule. A literal is
a form of constant expression, so is evaluated (primarily) at compile time.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="strings"><a class="header" href="#strings">Strings</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>Example</th><th>Characters</th><th>Escapes</th></tr></thead><tbody>
<tr><td><a href="spec/lexical_structure/tokens.html#string-literals">String</a></td><td><code>&quot;hello&quot;</code></td><td>ASCII subset</td><td><a href="spec/lexical_structure/tokens.html#quote-escapes">Quote</a> &amp; <a href="spec/lexical_structure/tokens.html#ascii-escapes">ASCII</a></td></tr>
</tbody></table>
</div>
<h4 id="ascii-escapes"><a class="header" href="#ascii-escapes">ASCII escapes</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
</tbody></table>
</div>
<h4 id="quote-escapes"><a class="header" href="#quote-escapes">Quote escapes</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\&quot;</code></td><td>Double quote</td></tr>
</tbody></table>
</div>
<h4 id="numbers"><a class="header" href="#numbers">Numbers</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="spec/lexical_structure/tokens.html#number-literals">Number literals</a><code>*</code></th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal integer</td><td><code>98_222</code></td></tr>
<tr><td>Hex integer</td><td><code>0xff</code></td></tr>
<tr><td>Octal integer</td><td><code>0o77</code></td></tr>
<tr><td>Binary integer</td><td><code>0b1111_0000</code></td></tr>
</tbody></table>
</div>
<p><code>*</code> All number literals allow <code>_</code> as a visual separator: <code>1_234</code></p>
<h3 id="boolean-literals"><a class="header" href="#boolean-literals">Boolean literals</a></h3>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
BOOLEAN_LITERAL :<br />
¬†¬† <code>true</code> | <code>false</code></p>
</blockquote>
<h3 id="string-literals"><a class="header" href="#string-literals">String literals</a></h3>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
STRING_LITERAL :<br />
¬†¬† <code>&quot;</code> (<br />
¬†¬† ¬†¬† PRINTABLE_ASCII_CHAR<br />
¬†¬† ¬†¬† | QUOTE_ESCAPE<br />
¬†¬† ¬†¬† | ASCII_ESCAPE<br />
¬†¬† )<sup>*</sup> <code>&quot;</code></p>
<p>PRINTABLE_ASCII_CHAR :<br />
¬†¬† Any ASCII character between <code>0x1F</code> and <code>0x7E</code></p>
<p>QUOTE_ESCAPE :<br />
¬†¬† <code>\&quot;</code></p>
<p>ASCII_ESCAPE :<br />
¬†¬† | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code></p>
</blockquote>
<p>A <em>string literal</em> is a sequence of any characters that are in the set of
printable ASCII characters as well as a set of defined escape sequences.</p>
<p>Line breaks are allowed in string literals.</p>
<h3 id="integer-literals"><a class="header" href="#integer-literals">Integer literals</a></h3>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
INTEGER_LITERAL :<br />
¬†¬† ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL )</p>
<p>DEC_LITERAL :<br />
¬†¬† DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>BIN_LITERAL :<br />
¬†¬† <code>0b</code> (BIN_DIGIT|<code>_</code>)<sup>*</sup> BIN_DIGIT (BIN_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>OCT_LITERAL :<br />
¬†¬† <code>0o</code> (OCT_DIGIT|<code>_</code>)<sup>*</sup> OCT_DIGIT (OCT_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>HEX_LITERAL :<br />
¬†¬† <code>0x</code> (HEX_DIGIT|<code>_</code>)<sup>*</sup> HEX_DIGIT (HEX_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>BIN_DIGIT : [<code>0</code>-<code>1</code>]</p>
<p>OCT_DIGIT : [<code>0</code>-<code>7</code>]</p>
<p>DEC_DIGIT : [<code>0</code>-<code>9</code>]</p>
<p>HEX_DIGIT : [<code>0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F</code>]</p>
</blockquote>
<p>An <em>integer literal</em> has one of four forms:</p>
<ul>
<li>A <em>decimal literal</em> starts with a <em>decimal digit</em> and continues with any
mixture of <em>decimal digits</em> and <em>underscores</em>.</li>
<li>A <em>hex literal</em> starts with the character sequence <code>U+0030</code> <code>U+0078</code>
(<code>0x</code>) and continues as any mixture (with at least one digit) of hex digits
and underscores.</li>
<li>An <em>octal literal</em> starts with the character sequence <code>U+0030</code> <code>U+006F</code>
(<code>0o</code>) and continues as any mixture (with at least one digit) of octal digits
and underscores.</li>
<li>A <em>binary literal</em> starts with the character sequence <code>U+0030</code> <code>U+0062</code>
(<code>0b</code>) and continues as any mixture (with at least one digit) of binary digits
and underscores.</li>
</ul>
<p>Examples of integer literals of various forms:</p>
<pre><code class="language-fe ignore">123                      // type u256
0xff                     // type u256
0o70                     // type u256
0b1111_1111_1001_0000    // type u256
0b1111_1111_1001_0000i64 // type u256
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
LINE_COMMENT :<br />
¬†¬† ¬†¬† <code>//</code> <sup>*</sup></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items"><a class="header" href="#items">Items</a></h1>
<ul>
<li><a href="spec/items/./visibility_and_privacy.html">Visibility and Privacy</a></li>
<li><a href="spec/items/./structs.html">Structs</a></li>
<li><a href="spec/items/./enums.html">Enums</a></li>
<li><a href="spec/items/./type_aliases.html">Type Aliases</a></li>
<li><a href="spec/items/./contracts.html">Contracts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-and-privacy"><a class="header" href="#visibility-and-privacy">Visibility and Privacy</a></h1>
<p>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question &quot;Can this item be used at this location?&quot;</p>
<p>Fe knows two different types of visibility for functions and state variables: <code>public</code> and <code>private</code>. Visibility of <code>private</code> is the default and is used if no other visibility is specified.</p>
<p><strong>Public:</strong> External functions are part of the contract interface, which means they can be called from other contracts and via transactions.</p>
<p><strong>Private:</strong> Those functions and state variables can only be accessed internally from within the same contract. This is the default visibility.</p>
<p>For example, this is a function that can be called externally from a transaction:</p>
<pre><code class="language-fe">pub fn answer_to_life_the_universe_and_everything() -&gt; u256 {
    return 42
}
</code></pre>
<p>Top-level definitions in a Fe source file can also be specified as <code>pub</code> if the file exists within the context of an Ingot. Declaring a definition as <code>pub</code> enables other modules within an Ingot to <code>use</code> the definition.</p>
<p>For example, given an Ingot with the following structure:</p>
<pre><code>example_ingot
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ ding
    ‚îÇ   ‚îî‚îÄ‚îÄ dong.fe
    ‚îî‚îÄ‚îÄ main.fe
</code></pre>
<p>With <code>ding/dong.fe</code> having the following contents:</p>
<pre><code class="language-fe">pub struct Dang {
    pub my_address: address
    pub my_u256: u256
    pub my_i8: i8
}
</code></pre>
<p>Then <code>main.fe</code> can use the <code>Dang</code> struct since it is <code>pub</code>-qualified:</p>
<pre><code class="language-fe ignore">use ding::dong::Dang

contract Foo {
    pub fn hot_dang() -&gt; Dang {
        return Dang(
            my_address: 8,
            my_u256: 42,
            my_i8: -1
        )
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Struct</em> :<br />
¬†¬† <code>struct</code> <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>{</code><br />
¬†¬† ¬†¬† <em>StructField</em><sup>*</sup><br />
¬†¬† ¬†¬† <em>StructMethod</em><sup>*</sup><br />
¬†¬† <code>}</code></p>
<p><em>StructField</em> :<br />
¬†¬† <code>pub</code>? <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>:</code> <a href="spec/items/../type_system/types/index.html"><em>Type</em></a></p>
<p><em>StructMethod</em> :<br />
¬†¬† <a href="spec/items/../items/functions/index.html"><em>Function</em></a></p>
</blockquote>
<p>A <em>struct</em> is a nominal <a href="spec/items/../type_system/types/struct.html">struct type</a> defined with the keyword <code>struct</code>.</p>
<p>An example of a <code>struct</code> item and its use:</p>
<pre><code class="language-fe">struct Point {
    pub x: u256
    pub y: u256
}

fn pointy_stuff() {
    let mut p: Point = Point(x: 10, y: 11)
    let px: u256 = p.x
    p.x = 100
}
</code></pre>
<p>Builtin functions:</p>
<ul>
<li><code>abi_encode()</code> encodes the struct as an ABI tuple and returns the encoded data as a fixed-size byte array that is equal in size to the encoding.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Trait</em> :<br />
¬†¬† <code>trait</code> <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>{</code><br />
¬†¬† ¬†¬† <em>TraitMethod</em><sup>*</sup><br />
¬†¬† <code>}</code></p>
<p><em>TraitMethod</em> :<br />
¬†¬† <code>fn</code> <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a><br />
¬†¬† ¬†¬† <code>(</code> <em>FunctionParameters</em><sup>?</sup> <code>)</code><br />
¬†¬† ¬†¬† <em>FunctionReturnType</em><sup>?</sup> <code>;</code></p>
</blockquote>
<p>A <em>trait</em> is a collection of function signatures that a type can implement. Traits are implemented for specific types through separate implementations. A type can implement a trait by providing a function body for each of the trait's functions. Traits can be used as type bounds for generic functions to restrict the types that can be used with the function.</p>
<p>All traits define an implicit type parameter <code>Self</code> that refers to &quot;the type that is implementing this interface&quot;. </p>
<p>Example of the <code>Min</code> trait from Fe's standard library:</p>
<pre><code class="language-fe">pub trait Min {
  fn min() -&gt; Self;
}
</code></pre>
<p>Example of the <code>i8</code> type implementing the <code>Min</code> trait:</p>
<pre><code class="language-fe">impl Min for i8 {
  fn min() -&gt; Self {
    return -128
  }
}
</code></pre>
<p>Example of a function restricting a generic parameter to types implementing the <code>Compute</code> trait:</p>
<pre><code class="language-fe">pub trait Compute {
  fn compute(self) -&gt; u256;
}

struct Example {
  fn do_something&lt;T: Compute&gt;(val: T) -&gt; u256 {
    return val.compute()
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Enumeration</em> :<br />
¬†¬† <code>enum</code> <a href="spec/items/../lexical_structure/identifiers.html"><em>IDENTIFIER</em></a> <code>{</code><br />
¬†¬† ¬†¬† <em>EnumField</em><sup>*</sup><br />
¬†¬† ¬†¬† <em>EnumMethod</em><sup>*</sup><br />
¬†¬† <code>}</code></p>
<p><em>EnumField</em> :<br />
¬†¬† <a href="spec/items/../lexical_structure/identifiers.html"><em>IDENTIFIER</em></a> | <a href="spec/items/../lexical_structure/identifiers.html"><em>IDENTIFIER</em></a><code>(</code><em>TupleElements</em><sup>?</sup><code>)</code></p>
<p><em>EnumMethod</em> :<br />
¬†¬† <a href="spec/items/../items/functions/index.html"><em>Function</em></a></p>
<p><em>TupleElements</em> :<br />
¬†¬† <a href="spec/items/../type_system/types/index.html"><em>Type</em></a> ( <code>,</code> <a href="spec/items/../type_system/types/index.html"><em>Type</em></a> )<sup>*</sup></p>
</blockquote>
<p>An <em>enum</em>, also referred to as <em>enumeration</em> is a simultaneous definition of a
nominal <a href="spec/items/../type_system/types/enum.html">Enum type</a>, that can be used to create or pattern-match values of the corresponding type.</p>
<p>Enumerations are declared with the keyword <code>enum</code>.</p>
<p>An example of an <code>enum</code> item and its use:</p>
<pre><code class="language-fe ignore">enum Animal {
    Dog
    Cat
    Bird(BirdType)
    
    pub fn bark(self) -&gt; String&lt;10&gt; {
        match self {
            Animal::Dog =&gt; {
                return &quot;bow&quot;
            }

            Animal::Cat =&gt; {
                return &quot;meow&quot;
            }
            
            Animal::Bird(BirdType::Duck) =&gt; {
                return &quot;quack&quot;
            }
            
            Animal::Bird(BirdType::Owl) =&gt; {
                return &quot;hoot&quot;
            }
        }
    }
}

enum BirdType {
    Duck
    Owl
}

fn f() {
    let barker: Animal = Animal::Dog
    barker.bark()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypeAlias</em> :<br />
¬†¬† <code>type</code> <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a>¬†<code>=</code> <a href="spec/items/../type_system/types/index.html"><em>Type</em></a></p>
</blockquote>
<p>A <em>type alias</em> defines a new name for an existing <a href="spec/items/../type_system/types/index.html">type</a>. Type aliases are
declared with the keyword <code>type</code>.</p>
<p>For example, the following defines the type <code>BookMsg</code> as a synonym for the type
<code>u8[100]</code>, a sequence of <code>100</code> <code>u8</code> numbers which is how sequences of bytes are represented in Fe.</p>
<pre><code class="language-fe">type BookMsg = Array&lt;u8, 100&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contracts"><a class="header" href="#contracts">Contracts</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Contract</em> :<br />
¬†¬† <code>contract</code> <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>{</code><br />
¬†¬†<em>ContractMember</em><sup>*</sup><br />
¬†¬†_<code>}</code></p>
<p><em>ContractMember</em>:<br />
¬†¬† <a href="spec/items/./visibility_and_privacy.html"><em>Visibility</em></a><sup>?</sup><br />
¬†¬† (<br />
¬†¬† ¬†¬† ¬†¬†  <em>ContractField</em><br />
¬†¬† ¬†¬† | <a href="spec/items/../type_system/types/function.html"><em>Function</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/./structs.html"><em>Struct</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/./enums.html"><em>Enum</em></a><br />
¬†¬† )</p>
<p><em>Visibility</em> :<br />
¬†¬† <code>pub</code><sup>?</sup></p>
<p><em>ContractField</em> :<br />
¬†¬† <a href="spec/items/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>:</code> <a href="spec/items/../type_system/types/index.html"><em>Type</em></a></p>
</blockquote>
<p>A <em>contract</em> is a piece of executable code stored at an address on the blockchain. See <em>Appendix A.</em> in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper</a> for more info. Contracts can be written in high level languages, like Fe, and then compiled to EVM bytecode for deployment to the blockchain. </p>
<p>Once the code is deployed to the blockchain, the contract's functions can be invoked by sending a transaction to the contract address (or a <code>call</code>, for functions that do not modify blockchain data). </p>
<p>In Fe, contracts are defined in files with <code>.fe</code> extensions and compiled using <code>fe build</code>.</p>
<p>A contract is denoted using the <code>contract</code> keyword. A contract definition adds a new contract type to the module. This <a href="spec/items/../type_system/types/contract.html">contract type</a> may be used for calling existing contracts with the same interface or initializing new contracts with the create methods.</p>
<p>An example of a <code>contract</code>:</p>
<pre><code class="language-fe">struct Signed {
    pub book_msg: String&lt;100&gt;
}

contract GuestBook {
    messages: Map&lt;address, String&lt;100&gt;&gt;

    pub fn sign(mut self, mut ctx: Context, book_msg: String&lt;100&gt;) {
        self.messages[ctx.msg_sender()] = book_msg
        ctx.emit(Signed(book_msg: book_msg))
    }

    pub fn get_msg(self, addr: address) -&gt; String&lt;100&gt; {
        return self.messages[addr].to_mem()
    }
}
</code></pre>
<p>Multiple contracts can be compiled from a single <code>.fe</code> contract file.</p>
<h2 id="pragma"><a class="header" href="#pragma">pragma</a></h2>
<p>An optional <code>pragma</code> statement can be placed at the beginning of a contract. They are used to enable developers to express that certain code is meant to be compiled with a specific compiler version such that non-matching compiler versions will reject it.</p>
<p>Read more on <a href="spec/items/../statements/pragma.html">pragma</a></p>
<h2 id="state-variables"><a class="header" href="#state-variables">State variables</a></h2>
<p>State variables are permanently stored in the contract storage on the blockchain. State variables must be declared inside the contract body but outside the scope of any individual contract function. </p>
<pre><code class="language-fe">pub contract Example {
    some_number: u256
    _some_string: String&lt;100&gt;
}
</code></pre>
<h3 id="contract-functions"><a class="header" href="#contract-functions">Contract functions</a></h3>
<p>Functions are executable blocks of code. Contract functions are defined inside the body of a contract, but functions defined at module scope (outside of any contract) can be called from within a contract as well. </p>
<p>Individual functions can be called internally or externally depending upon their <a href="spec/items/../items/visibility_and_privacy.html">visibility</a> (either <code>private</code> or <code>public</code>).</p>
<p>Functions can modify either (or neither) the contract instance or the blockchain. This can be inferred from the function signature by the presence of combinations of <code>mut</code>, <code>self</code> and <code>Context</code>. If a function modifies the contract instance it requires <code>mut self</code> as its first argument. If a function modifies the blockchain it requires <code>Context</code> as an argument.</p>
<p>Read more on <a href="spec/items/../../spec/items/functions/index.html">functions</a>.</p>
<h3 id="the-__init__-function"><a class="header" href="#the-__init__-function">The <code>__init__()</code> function</a></h3>
<p>The <code>__init__</code> function is a special contract function that can only be called at <em>contract deployment time</em>. It is mostly used to set initial values to state variables upon deployment. In other contexts, <code>__init__()</code> is commonly referred to as the <code>constructor</code> function.</p>
<pre><code class="language-fe">pub contract Example {

    _some_number: u256
    _some_string: String&lt;100&gt;

    pub fn __init__(mut self, number: u256, string: String&lt;100&gt;)  {
        self._some_number=number;
        self._some_string=string;
    }
}
</code></pre>
<p>It is <strong>not possible</strong> to call <code>__init__</code> at runtime.</p>
<h2 id="structs-1"><a class="header" href="#structs-1">Structs</a></h2>
<p>Structs might also exist inside a contract file. These are declared outside of the contract body and are used to define a group of variables that can be used for some specific purpose inside the contract. In Fe structs are also used to represent an <code>Event</code> or an <code>Error</code>.</p>
<p>Read more on <a href="spec/items/../../spec/items/structs.html">structs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Constant size values stored on the stack or in memory can be passed into and returned by functions.</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Function</em> :<br />
¬†¬† <em>FunctionQualifiers</em> <code>fn</code> <a href="spec/items/functions/../../lexical_structure/identifiers.html">IDENTIFIER</a><br />
¬†¬† ¬†¬† <code>(</code> <em>FunctionParameters</em><sup>?</sup> <code>)</code><br />
¬†¬† ¬†¬† <em>FunctionReturnType</em><sup>?</sup><br />
¬†¬† ¬†¬† <code>{</code><br />
¬†¬† ¬†¬† <em>FunctionStatements</em><sup>*</sup><br />
¬†¬† ¬†¬† <code>}</code></p>
<p><em>FunctionQualifiers</em> :<br />
¬†¬† <code>pub</code><sup>?</sup></p>
<p><em>FunctionStatements</em> :<br />
¬†¬† ¬†¬† ¬†¬†  <a href="spec/items/functions/../../statements/return.html"><em>ReturnStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/let.html"><em>VariableDeclarationStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/assign.html"><em>AssignStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/augassign.html"><em>AugmentedAssignStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/for.html"><em>ForStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/for.html"><em>WhileStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/if.html"><em>IfStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/assert.html"><em>AssertStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/break.html"><em>BreakStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/continue.html"><em>ContinueStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../statements/revert.html"><em>RevertStatement</em></a><br />
¬†¬† ¬†¬† | <a href="spec/items/functions/../../expressions/index.html"><em>Expression</em></a></p>
<p><em>FunctionParameters</em> :<br />
¬†¬†  <code>self</code><sup>?</sup> | <code>self,</code><sup>?</sup>   <em>FunctionParam</em> (<code>,</code> <em>FunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>FunctionParam</em> :<br />
¬†¬† <em>FunctionParamLabel</em><sup>?</sup> <a href="spec/items/functions/../../lexical_structure/identifiers.html">IDENTIFIER</a> <code>:</code> <a href="spec/items/functions/../../type_system/types/index.html"><em>Types</em></a></p>
<p><em>FunctionParamLabel</em> :<br />
¬†¬† _ | <a href="spec/items/functions/../../lexical_structure/identifiers.html">IDENTIFIER</a></p>
<p><em>FunctionReturnType</em> :<br />
¬†¬† <code>-&gt;</code> <a href="spec/items/functions/../../type_system/types/index.html"><em>Types</em></a></p>
</blockquote>
<p>A <em>function</em> definition consists of name and code block along with an optional
list of parameters and return value. Functions are declared with the
keyword <code>fn</code>. Functions may declare a set of <em>input</em> parameters,
through which the caller passes arguments into the function, and
the <em>output</em> <a href="spec/items/functions/../../type_system/types/index.html"><em>type</em></a> of the value the function will return to its caller
on completion.</p>
<p>When referred to, a <em>function</em> yields a first-class <em>value</em> of the
corresponding zero-sized <a href="spec/items/functions/../../type_system/types/function.html"><em>function type</em></a>, which
when called evaluates to a direct call to the function.</p>
<p>A function header prepends a set or curly brackets <code>{...}</code> which contain the function body.</p>
<p>For example, this is a simple function:</p>
<pre><code class="language-fe">fn add(x: u256, y: u256) -&gt; u256 {
    return x + y
}
</code></pre>
<p>Functions can be defined inside of a contract, inside of a struct, or at the
&quot;top level&quot; of a module (that is, not nested within another item).</p>
<p>Example:</p>
<pre><code class="language-fe">fn add(_ x: u256, _ y: u256) -&gt; u256 {
    return x + y
}

contract CoolCoin {
    balance: Map&lt;address, u256&gt;

    fn transfer(mut self, from sender: address, to recipient: address, value: u256) -&gt; bool {
        if self.balance[sender] &lt; value {
            return false
        }
        self.balance[sender] -= value
        self.balance[recipient] += value
        return true
    }
    pub fn demo(mut self) {
        let ann: address = 0xaa
        let bob: address = 0xbb
        self.balance[ann] = 100

        let bonus: u256 = 2
        let value: u256 = add(10, bonus)
        let ok: bool = self.transfer(from: ann, to: bob, value)
    }
}
</code></pre>
<p>Function parameters have optional labels. When a function is called, the
arguments must be labeled and provided in the order specified in the
function definition.</p>
<p>The label of a parameter defaults to the parameter name; a different label
can be specified by adding an explicit label prior to the parameter name.
For example:</p>
<pre><code class="language-fe">fn encrypt(msg cleartext: u256, key: u256) -&gt; u256 {
    return cleartext ^ key
}

fn demo() {
    let out: u256 = encrypt(msg: 0xdecafbad, key: 0xfefefefe)
}
</code></pre>
<p>Here, the first parameter of the <code>encrypt</code> function has the label <code>msg</code>,
which is used when calling the function, while the parameter name is
<code>cleartext</code>, which is used inside the function body. The parameter name
is an implementation detail of the function, and can be changed without
modifying any function calls, as long as the label remains the same.</p>
<p>When calling a function, a label can be omitted when the argument is
a variable with a name that matches the parameter label. Example:</p>
<pre><code class="language-fe ignore">let msg: u256 = 0xdecafbad
let cyf: u256 = encrypt(msg, key: 0x1234)
</code></pre>
<p>A parameter can also be specified to have no label, by using <code>_</code> in place of a
label in the function definition. In this case, when calling the function, the
corresponding argument must not be labeled. Example:</p>
<pre><code class="language-fe">fn add(_ x: u256, _ y: u256) -&gt; u256 {
    return x + y
}
fn demo() {
    let sum: u256 = add(16, 32)
}
</code></pre>
<p>Functions defined inside of a contract or struct may take <a href="spec/items/functions/./self.html"><code>self</code></a> as a
parameter. This gives the function the ability to read and write contract
storage or struct fields, respectively. If a function takes <code>self</code>
as a parameter, the function must be called via <code>self</code>. For example:</p>
<pre><code class="language-fe ignore">let ok: bool = self.transfer(from, to, value)
</code></pre>
<p><code>self</code> is expected to come <em>first</em> parameter in the function's parameter list.</p>
<p>Functions can also take a <a href="spec/items/functions/./context.html"><code>Context</code></a> object which gives access to EVM features that read or write
blockchain and transaction data. <code>Context</code> is expected to be <em>first</em> in the function's parameter list
unless the function takes <code>self</code>, in which case <code>Context</code> should come second.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-1"><a class="header" href="#context-1">Context</a></h1>
<p><code>Context</code> is used frequently in Fe smart contracts. It is used to gate access to EVM features for reading and modifying the blockchain.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>Smart contracts execute on the Ethereum Virtual Machine (EVM). The EVM exposes features that allow smart contracts to query or change some of the blockchain data, for example emitting logs that are included in transaction receipts, creating contracts, obtaining the current block number and altering the data stored at certain addresses.</p>
<p>To make Fe maximally explicit and as easy as possible to audit, these functions are gated behind a <code>Context</code> object. This is passed as an argument to functions, making it clear whether a function interacts with EVM features from the function signature alone. </p>
<p>For example, the following function looks pure from its signature (i.e. it is not expected to alter any blockchain data) but in reality it does modify the blockchain (by emitting a log).</p>
<pre><code class="language-fe ignore">pub fn looks_pure_but_isnt() {
  // COMPILE ERROR
  block_number()
}
</code></pre>
<p>Using <code>Context</code> to control access to EVM functions such as <code>emit</code> solves this problem by requiring an instance of <code>Context</code> to be passed explicitly to the function, making it clear from the function signature that the function executes some blockchain interaction. The function above, rewritten using <code>Context</code>, looks as follows:</p>
<pre><code class="language-fe">pub fn uses_context(ctx: Context) -&gt; u256 {
    return ctx.block_number()
}
</code></pre>
<h2 id="the-context-object"><a class="header" href="#the-context-object">The Context object</a></h2>
<p>The Context object gates access to features such as:</p>
<ul>
<li>emitting logs</li>
<li>creating contracts</li>
<li>transferring ether</li>
<li>reading message info</li>
<li>reading block info</li>
</ul>
<p>The <code>Context</code> object needs to be passed as a parameter to the function. The <code>Context</code> object has a defined location in the parameter list. It is the <em>first</em> parameter unless the function also takes <code>self</code>. <code>Context</code> or <code>self</code> appearing at any other position in the parameter list causes a compile time error.</p>
<p>The Context object is automatically injected when a function is called externally but it has to be passed explicitly when the function is called from another Fe function e.g.</p>
<pre><code class="language-fe">// The context object is automatically injected when this is called externally
pub fn multiply_block_number(ctx: Context) -&gt; u256 {
  // but it has to be passed along in this function call
  return retrieves_blocknumber(ctx) * 1000
}

fn retrieves_blocknumber(ctx: Context) -&gt; u256 {
  return ctx.block_number()
}
</code></pre>
<h2 id="context-mutability"><a class="header" href="#context-mutability">Context mutability</a></h2>
<p>All functionality that modifies the blockchain such as creating logs or contracts or transferring ether would require a mutable <code>Context</code> reference whereas read-only access such as <code>ctx.block_number()</code> does not need require a mutable reference to the context. To pass a mutable <code>Context</code> object, prepend the object name with <code>mut</code> in the function definition, e.g.:</p>
<pre><code class="language-fe">struct SomeEvent{
}

pub fn mutable(mut ctx: Context) {
    ctx.emit(SomeEvent())
}
</code></pre>
<h2 id="abi-conformity"><a class="header" href="#abi-conformity">ABI conformity</a></h2>
<p>The use of <code>Context</code> enables tighter rules and extra clarity compared wth the existing function categories in the ABI, especially when paired with <a href="spec/items/functions/self.html"><code>self</code></a>. The following table shows how combinations of <code>self</code>, <code>mut self</code>, <code>Context</code> and <code>mut Context</code> map to ABI function types.</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Characteristics</th><th>Fe Syntax</th><th>ABI</th></tr></thead><tbody>
<tr><td>Pure</td><td>Can only operate on input arguments and not produce any information besides its return value. Can not take self and therefore has no access to things that would make it impure</td><td><code>foo(val: u256)</code></td><td>pure</td></tr>
<tr><td>Read Contract</td><td>Reading information from the contract instance (broad definition includes reading constants from contract code)</td><td><code>foo(self)</code></td><td>view</td></tr>
<tr><td>Storage Writing</td><td>Writing to contract storage (own or that of other contracts)</td><td><code>foo(mut self)</code></td><td>payable or nonpayable</td></tr>
<tr><td>Context Reading</td><td>Reading contextual information from the blockchain (<code>msg</code>, <code>block</code> etc)</td><td><code>foo(ctx: Context)</code></td><td>view</td></tr>
<tr><td>Context Modifying</td><td>Emitting logs, transferring ether, creating contracts</td><td><code>foo(ctx: mut Context)</code></td><td>payable or nonpayable</td></tr>
<tr><td>Read Contract &amp; <code>Context</code></td><td>Reading information from the contract instance and <code>Context</code></td><td><code>foo(self, ctx:Context)</code></td><td>view</td></tr>
<tr><td>Read Contract &amp; write <code>Context</code></td><td>Reading information from the contract instance and modify <code>Context</code></td><td><code>foo(self, ctx: mut Context)</code></td><td>view</td></tr>
<tr><td>Storage Writing &amp; read <code>Context</code></td><td>Writing to contract storage and read from <code>Context</code></td><td><code>foo(mut self, ctx: Context)</code></td><td>payable or nonpayable</td></tr>
<tr><td>Storage Writing &amp; write <code>Context</code></td><td>Writing to contract storage and <code>Context</code></td><td><code>foo(mut self, ctx: mut Context)</code></td><td>payable or nonpayable</td></tr>
</tbody></table>
</div>
<p>This means Fe has nine different categories of function that can be derived from the function signatures that map to four different ABI types.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="msg_sender-and-msg_value"><a class="header" href="#msg_sender-and-msg_value">msg_sender and msg_value</a></h3>
<p><code>Context</code> includes information about inbound transactions. For example, the following function receives ether and adds the sender's address and the
transaction value to a mapping. No blockchain data is being changed, so <code>Context</code> does not need to be mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// assumes existence of state variable named 'ledger' with type Map&lt;address, u256&gt;
pub fn add_to_ledger(mut self, ctx: Context) {
    self.ledger[ctx.msg_sender()] = ctx.msg_value();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transferring-ether"><a class="header" href="#transferring-ether">Transferring ether</a></h3>
<p>Transferring ether modifies the blockchain state, so it requires access to a mutable <code>Context</code> object.</p>
<pre><code class="language-fe">pub fn send_ether(mut ctx: Context, _addr: address, amount: u256) {
    ctx.send_value(to: _addr, wei: amount)
}
</code></pre>
<h3 id="createcreate2"><a class="header" href="#createcreate2">create/create2</a></h3>
<p>Creating a contract via <code>create</code>/<code>create2</code> requires access to a mutable <code>Context</code> object because it modifies the blockchain state data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn creates_contract(ctx: mut Context):
  ctx.create2(...)
<span class="boring">}</span></code></pre></pre>
<h3 id="block-number"><a class="header" href="#block-number">block number</a></h3>
<p>Reading block chain information such as the current block number requires <code>Context</code> (but does not require it to be mutable). </p>
<pre><code class="language-fe">pub fn retrieves_blocknumber(ctx: Context) {
  ctx.block_number()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-1"><a class="header" href="#self-1">Self</a></h1>
<p><code>self</code> is used to represent the specific instance of a Contract. It is used to access variables that are owned by that specific instance. This works the same way for Fe contracts as for, e.g. <code>self</code> in the context of classes in Python, or <code>this</code> in Javascript. <code>self</code> gives access to constants from the contract code and state variables from contract storage.</p>
<blockquote>
<p>Note: Here we focus on functions defined inside a contract, giving access to contract storage; however, <code>self</code> can also be used to read and write <code>struct</code> fields where functions are defined inside <code>structs</code>.</p>
</blockquote>
<p>If a function takes self as a parameter, the function must be called via self. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ok: bool = self.transfer(from, to, value)
<span class="boring">}</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p><code>self</code> is immutable and can be used for read-only operations on the contract storage (or <code>struct</code> fields). In order to write to the contract storage, you must use <code>mut self</code>. This makes the contract instance mutable and allows the contract storage to be updated.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="reading-contract-storage"><a class="header" href="#reading-contract-storage">Reading contract storage</a></h3>
<pre><code class="language-fe">contract example {

    value: u256;

    pub fn check_value(self) -&gt; u256 {
        return self.value;
    }
}
</code></pre>
<h3 id="writing-contract-storage"><a class="header" href="#writing-contract-storage">Writing contract storage</a></h3>
<pre><code class="language-fe">contract example {

    value: u256;

    pub fn update_value(mut self) {
        self.value += 1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<ul>
<li><a href="spec/statements/./pragma.html">pragma Statement</a></li>
<li><a href="spec/statements/./const.html">const Statement</a></li>
<li><a href="spec/statements/./let.html">let Statement</a></li>
<li><a href="spec/statements/./assign.html">Assignment Statement</a></li>
<li><a href="spec/statements/./augassign.html">Augmenting Assignment Statement</a></li>
<li><a href="spec/statements/./revert.html">revert Statement</a></li>
<li><a href="spec/statements/./return.html">return Statemetn</a></li>
<li><a href="spec/statements/./if.html">if Statement</a></li>
<li><a href="spec/statements/./for.html">for Statement</a></li>
<li><a href="spec/statements/./while.html">while Statement</a></li>
<li><a href="spec/statements/./break.html">break Statement</a></li>
<li><a href="spec/statements/./continue.html">continue Statement</a></li>
<li><a href="spec/statements/./match.html">match Statement</a></li>
<li><a href="spec/statements/./assert.html">assert Statement</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragma-statement"><a class="header" href="#pragma-statement"><code>pragma</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PragmaStatement</em> :<br />
¬†¬† <code>pragma</code> <em>VersionRequirement</em></p>
<p><em>VersionRequirement</em> :<sub>Following the semver implementation by <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">cargo</a> </sub></p>
</blockquote>
<p>The pragma statement is denoted with the keyword <code>pragma</code>. Evaluating a <code>pragma</code>
statement will cause the compiler to reject compilation if the version of the compiler does not conform to the given version requirement.</p>
<p>An example of a <code>pragma</code> statement:</p>
<pre><code class="language-fe ignore">pragma ^0.1.0
</code></pre>
<p>The version requirement syntax is identical to the one that is used by cargo (<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">more info</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-statement"><a class="header" href="#const-statement"><code>const</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ConstStatement</em> :<br />
¬†¬† <code>const</code> <a href="spec/statements/../lexical_structure/identifiers.html">IDENTIFIER</a><code>:</code> <a href="spec/statements/../type_system/types/index.html"><em>Type</em></a> <code>=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a></p>
</blockquote>
<p>A <code>const</code> statement introduces a named constant value. Constants are either directly inlined wherever they are used or loaded from the contract code depending on their type.</p>
<p>Example:</p>
<pre><code class="language-fe">const TEN: u256 = 10
const HUNDO: u256 = TEN * TEN

contract Foo {
  pub fn bar() -&gt; u256 {
    return HUNDO
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-statement"><a class="header" href="#let-statement"><code>let</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LetStatement</em> :<br />
¬†¬† <code>let</code> <a href="spec/statements/../lexical_structure/identifiers.html">IDENTIFIER</a> | <em>TupleTarget</em> <code>:</code> <a href="spec/statements/../type_system/types/index.html"><em>Type</em></a> <code>=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a></p>
<p><em>TupleTarget</em> :<br />
¬†¬† <code>(</code> <em>TupleTargetItem</em> (<code>,</code> <em>TupleTargetItem</em>) <sup>+</sup> <code>)</code></p>
<p><em>TupleTargetItem</em> :<br />
¬†¬† <a href="spec/statements/../lexical_structure/identifiers.html">IDENTIFIER</a> | <em>TupleTarget</em></p>
</blockquote>
<p>A <code>let</code> statement introduces a new set of variables. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</p>
<blockquote>
<p>Note: Support for nested tuples isn't yet implemented but can be tracked via this <a href="https://github.com/ethereum/fe/issues/427">GitHub issue</a>.</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

  pub fn bar() {
    let val1: u256 = 1
    let (val2):(u256) = (1,)
    let (val3, val4):(u256, bool) = (1, false)
    let (val5, val6, (val7, val8)):(u256, bool, (u256, u256)) = (1, false, (2, 4))
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignment-statement"><a class="header" href="#assignment-statement">Assignment statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AssignmentStatement</em> :<br />
¬†¬† <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a></p>
</blockquote>
<p>An assignment statement moves a value into a specified place. An assignment statement consists of an expression that holds a mutable place, followed by an equals sign (=) and a value expression.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
  some_array: Array&lt;u256, 10&gt;


  pub fn bar(mut self) {
    let mut val1: u256 = 10
    // Assignment of stack variable
    val1 = 10

    let mut values: (u256, u256) = (1, 2)
    // Assignment of tuple item
    values.item0 = 3

    // Assignment of storage array slot
    self.some_array[5] = 1000
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="augmenting-assignment-statement"><a class="header" href="#augmenting-assignment-statement">Augmenting Assignment statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AssignmentStatement</em> :<br />
¬†¬† ¬†¬† <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>+=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>-=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>%=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>**=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>&lt;&lt;=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>&gt;&gt;=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>|=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>^=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>&amp;=</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a></p>
</blockquote>
<p><em>Augmenting assignment statements</em> combine arithmetic and logical binary operators with assignment statements.</p>
<p>An augmenting assignment statement consists of an expression that holds a mutable place, followed by one of the arithmetic or logical binary operators, followed by an equals sign (=) and a value expression.</p>
<p>Example:</p>
<pre><code class="language-fe">fn example() -&gt; u8 {
    let mut a: u8 = 1
    let b: u8 = 2
    a += b
    a -= b
    a *= b
    a /= b
    a %= b
    a **= b
    a &lt;&lt;= b
    a &gt;&gt;= b
    a |= b
    a ^= b
    a &amp;= b
    return a
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revert-statement"><a class="header" href="#revert-statement"><code>revert</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RevertStatement</em> :<br />
¬†¬† <code>revert</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>The revert statement is denoted with the keyword <code>revert</code>. Evaluating a <code>revert</code>
statement will cause to revert all state changes made by the call and return with an revert error to the caller. A revert statement may be followed by an expression that evaluates to a <a href="spec/statements/../items/structs.html">struct</a> in which case the struct is encoded as revert data as defined by <a href="https://github.com/ethereum/EIPs/issues/838">EIP-838</a>.</p>
<p>An example of a <code>revert</code> statement without revert data:</p>
<pre><code class="language-fe">contract Foo {
    fn transfer(self, to: address, value: u256) {
        if not self.in_whitelist(addr: to) {
            revert
        }
        // more logic here
    }

    fn in_whitelist(self, addr: address) -&gt; bool {
        return false
    }
}
</code></pre>
<p>An example of a <code>revert</code> statement with revert data:</p>
<pre><code class="language-fe">struct ApplicationError {
    pub code: u8
}

contract Foo {
    pub fn transfer(self, to: address, value: u256) {
        if not self.in_whitelist(addr: to) {
            revert ApplicationError(code: 5)
        }
        // more logic here
    }

    fn in_whitelist(self, addr: address) -&gt; bool {
        return false
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-statement"><a class="header" href="#return-statement"><code>return</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReturnStatement</em> :<br />
¬†¬† <code>return</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>The return statement is denoted with the keyword <code>return</code>. A <code>return</code> statement leaves the current function call with a return value which is either the value of the evaluated expression (if present) or <code>()</code> (unit type) if <code>return</code> is not followed by an expression explicitly.</p>
<p>An example of a <code>return</code> statement without explicit use of an expression:</p>
<pre><code class="language-fe">contract Foo {
    fn transfer(self, to: address, value: u256) {
        if not self.in_whitelist(to) {
            return
        }
    }

    fn in_whitelist(self, to: address) -&gt; bool {
        // revert used as placeholder for actual logic
        revert
    }
}
</code></pre>
<p>The above can also be written in a slightly more verbose form:</p>
<pre><code class="language-fe">contract Foo {
    fn transfer(self, to: address, value: u256) -&gt; () {
        if not self.in_whitelist(to) {
            return ()
        }
    }

    fn in_whitelist(self, to: address) -&gt; bool {
        // revert used as placeholder for actual logic
        revert
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-statement"><a class="header" href="#if-statement"><code>if</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IfStatement</em> :<br />
¬†¬† <code>if</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a><code>{</code>
¬†¬† (<a href="spec/statements/./index.html"><em>Statement</em></a> | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a>)<sup>+</sup><br />
¬†¬† <code>}</code><br />
¬†¬† (<code>else</code> <code>{</code><br />
¬†¬† (<a href="spec/statements/./index.html"><em>Statement</em></a> | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a>)<sup>+</sup><br />
¬†¬† <code>}</code>)<sup>?</sup></p>
</blockquote>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
    pub fn bar(val: u256) -&gt; u256 {
        if val &gt; 5 {
            return 1
        } else {
            return 2
        }
    }
}
</code></pre>
<p>The <code>if</code> statement is used for conditional execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-statement"><a class="header" href="#for-statement"><code>for</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ForStatement</em> :<br />
¬†¬† <code>for</code> <a href="spec/statements/../lexical_structure/identifiers.html">IDENTIFIER</a> <code>in</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>{</code><br />
¬†¬† (<a href="spec/statements/./index.html"><em>Statement</em></a> | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a>)<sup>+</sup><br />
¬†¬† <code>}</code></p>
</blockquote>
<p>A <code>for</code> statement is a syntactic construct for looping over elements provided by an <a href="spec/statements/../type_system/types/array.html">array type</a>.</p>
<p>An example of a <code>for</code> loop over the contents of an array:</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar(values: Array&lt;u256, 10&gt;) -&gt; u256 {
        let mut sum: u256 = 0
        for i in values {
            sum = sum + i
        }
        return sum
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-statement"><a class="header" href="#while-statement"><code>while</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>WhileStatement</em> :<br />
¬†¬† <code>while</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>{</code><br />
¬†¬† (<a href="spec/statements/./index.html"><em>Statement</em></a> | <a href="spec/statements/../expressions/index.html"><em>Expression</em></a>)<sup>+</sup><br />
¬†¬† <code>}</code></p>
</blockquote>
<p>A <code>while</code> loop begins by evaluation the <a href="spec/statements/../type_system/types/boolean.html">boolean</a> loop conditional expression. If the loop conditional expression evaluates to <code>true</code>, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to <code>false</code>, the <code>while</code> expression completes.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar() -&gt; u256 {
        let mut sum: u256 = 0
        while sum &lt; 10 {
            sum += 1
        }
        return sum
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break-statement"><a class="header" href="#break-statement"><code>break</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BreakStatement</em> :<br />
¬†¬† <code>break</code></p>
</blockquote>
<p>The <code>break</code> statement can only be used within a <a href="spec/statements/./for.html"><code>for</code></a> or <a href="spec/statements/./while.html"><code>while</code></a> loop and causes the immediate termination of the loop.</p>
<p>If used within nested loops the <code>break</code> statement is associated with the innermost enclosing loop.</p>
<p>An example of a <code>break</code> statement used within a <a href="spec/statements/./while.html"><code>while</code></a> loop.</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar() -&gt; u256 {
        let mut sum: u256 = 0
        while sum &lt; 10 {
            sum += 1

            if some_abort_condition() {
                break
            }
        }
        return sum
    }

    fn some_abort_condition() -&gt; bool {
        // some complex logic
        return true
    }
}
</code></pre>
<p>An example of a <code>break</code> statement used within a <a href="spec/statements/./for.html"><code>for</code></a> loop.</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar(values: Array&lt;u256, 10&gt;) -&gt; u256 {
        let mut sum: u256 = 0
        for i in values {
            sum = sum + i

            if some_abort_condition() {
                break
            }
        }
        return sum
    }

    fn some_abort_condition() -&gt; bool {
        // some complex logic
        return true
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continue-statement"><a class="header" href="#continue-statement"><code>continue</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ContinueStatement</em> :<br />
¬†¬† <code>continue</code></p>
</blockquote>
<p>The <code>continue</code> statement can only be used within a <a href="spec/statements/./for.html"><code>for</code></a> or <a href="spec/statements/./while.html"><code>while</code></a> loop and causes the immediate termination of the current iteration, returning control to the loop head.</p>
<p>If used within nested loops the <code>continue</code> statement is associated with the innermost enclosing loop.</p>
<p>An example of a <code>continue</code> statement used within a <a href="spec/statements/./while.html"><code>while</code></a> loop.</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar() -&gt; u256 {
        let mut sum: u256 = 0
        while sum &lt; 10 {
            sum += 1

            if some_skip_condition() {
                continue
            }
        }

        return sum
    }

    fn some_skip_condition() -&gt; bool {
        // some complex logic
        return true
    }
}
</code></pre>
<p>An example of a <code>continue</code> statement used within a <a href="spec/statements/./for.html"><code>for</code></a> loop.</p>
<pre><code class="language-fe">contract Foo {

    pub fn bar(values: Array&lt;u256, 10&gt;) -&gt; u256 {
        let mut sum: u256 = 0
        for i in values {
            sum = sum + i

            if some_skip_condition() {
                continue
            }
        }
        return sum
    }

    fn some_skip_condition() -&gt; bool {
        // some complex logic
        return true
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-statement"><a class="header" href="#match-statement"><code>match</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MatchStatement</em> :<br />
¬†¬† <code>match</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> <code>{</code><br />
¬†¬† ¬†¬† ( <em>Pattern</em> <code>=&gt;</code> <code>{</code> <a href="spec/statements/./index.html"><em>Statement</em></a><sup>*</sup> <code>}</code> )<sup>+</sup><br />
¬†¬† <code>}</code></p>
<p><em>Pattern</em> : <br />
¬†¬† <em>PatternElem</em> ( <code>|</code> <em>PatternElem</em> )<sup>*</sup></p>
<p><em>PatternElem</em> : <br />
¬†¬† <a href="spec/statements/../lexical_structure/identifiers.html"><em>IDENTIFIER</em></a> | <a href="spec/statements/../lexical_structure/tokens.html#boolean-literals"><em>BOOLEAN_LITERAL</em></a> | <code>_</code> |  <code>..</code> | <a href="spec/statements/../expressions/path.html"><em>Path</em></a> |<br />
¬†¬† <a href="spec/statements/../expressions/path.html"><em>Path</em></a><code>(</code> <em>TuplePatterns</em><sup>?</sup> <code>)</code> |<code>(</code> <em>TuplePatterns</em><sup>?</sup> <code>)</code> |<br />
¬†¬† <a href="spec/statements/../expressions/path.html"><em>Path</em></a><code>{</code> <em>StructPatterns</em><sup>?</sup> <code>}</code></p>
<p><em>TuplePatterns</em> : <br />
¬†¬† <em>Pattern</em> ( <code>,</code> <em>Pattern</em> )<sup>*</sup></p>
<p><em>StructPatterns</em> : <br />
¬†¬† <em>Field</em> ( <code>,</code> <em>Field</em>)<sup>*</sup>(<code>,</code> <code>..</code>)<sup>?</sup></p>
<p><em>Field</em> : <br />
¬†¬† <a href="spec/statements/../lexical_structure/identifiers.html"><em>IDENTIFIER</em></a> <code>:</code> <em>Pattern</em></p>
</blockquote>
<p>A <code>match</code> statements compares <code>expression</code> with patterns, then executes body of the matched arm.</p>
<p>Example:</p>
<pre><code class="language-fe">enum MyEnum {
    Unit
    Tuple(u32, u256, bool)
}

contract Foo {
    pub fn bar(self) -&gt; u256 {
        let val: MyEnum = MyEnum::Tuple(1, 10, false)
        return self.eval(val)
    }
    
    fn eval(self, val: MyEnum) -&gt; u256 {
        match val {
            MyEnum::Unit =&gt; {
                return 0
            }
            
            MyEnum::Tuple(.., false) =&gt; {
                return 1
            }
            
            MyEnum::Tuple(a, b, true) =&gt; {
                return u256(a) + b
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-statement"><a class="header" href="#assert-statement"><code>assert</code> statement</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AssertStatement</em> :<br />
¬†¬† <code>assert</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a> (<code>,</code> <a href="spec/statements/../expressions/index.html"><em>Expression</em></a>)<sup>?</sup></p>
</blockquote>
<p>The <code>assert</code> statement is used express invariants in the code. It consists of a <a href="spec/statements/../type_system/types/boolean.html">boolean</a> expression optionally followed by a comma followed by a <a href="spec/statements/../type_system/types/string.html">string</a> expression.</p>
<p>If the <a href="spec/statements/../type_system/types/boolean.html">boolean</a> expression evaluates to <code>false</code>, the code reverts with a panic code of <code>0x01</code>. In the case that the first expression evaluates to <code>false</code> and a second <a href="spec/statements/../type_system/types/string.html">string</a> expression is given, the code reverts with the given string as the <a href="https://github.com/ethereum/EIPs/issues/838">error code</a>.</p>
<div class="warning">
<p>Warning:
The current implementation of <code>assert</code> is under <a href="https://github.com/ethereum/fe/issues/516">active discussion</a> and likely to change.</p>
</div>
<p>An example of a <code>assert</code> statement without the optional message:</p>
<pre><code class="language-fe">contract Foo {
    fn bar(val: u256) {
        assert val &gt; 5
    }
}
</code></pre>
<p>An example of a <code>assert</code> statement with an error message:</p>
<pre><code class="language-fe">contract Foo {

    fn bar(val: u256) {
        assert val &gt; 5, &quot;Must be greater than five&quot;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<ul>
<li><a href="spec/expressions/./call.html">Call expressions</a></li>
<li><a href="spec/expressions/./tuple.html">Tuple expressions</a></li>
<li><a href="spec/expressions/./list.html">List expressions</a></li>
<li><a href="spec/expressions/./struct.html">Struct expressions</a></li>
<li><a href="spec/expressions/./indexing.html">Index expressions</a></li>
<li><a href="spec/expressions/./attribute.html">Attribute expressions</a></li>
<li><a href="spec/expressions/./name.html">Name expressions</a></li>
<li><a href="spec/expressions/./path.html">Name expressions</a></li>
<li><a href="spec/expressions/./literal.html">Literal expressions</a></li>
<li><a href="spec/expressions/./arithmetic_operators.html">Arithmetic Operators</a></li>
<li><a href="spec/expressions/./comparison_operators.html">Comparison Operators</a></li>
<li><a href="spec/expressions/./boolean_operators.html">Boolean Operators</a></li>
<li><a href="spec/expressions/./unary_operators.html">Unary Operators</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-expressions"><a class="header" href="#call-expressions">Call expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>CallExpression</em> :<br />
¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <em>GenericArgs</em><sup>?</sup> <code>(</code> <em>CallParams</em><sup>?</sup> <code>)</code></p>
<p><em>GenericArgs</em> :<br />
¬†¬† <code>&lt;</code> <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a> | <a href="spec/expressions/../lexical_structure/tokens.html#integer-literals">INTEGER_LITERAL</a>  (<code>,</code> <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a> | <a href="spec/expressions/../lexical_structure/tokens.html#integer-literals">INTEGER_LITERAL</a>)<sup>*</sup> <code>&gt;</code></p>
<p><em>CallParams</em> :<br />
¬†¬† <em>CallArg</em>¬†( <code>,</code> <em>CallArg</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>CallArg</em> :<br />
¬†¬† (<em>CallArgLabel</em> <code>=</code>)<sup>?</sup> <a href="spec/expressions/./index.html"><em>Expression</em></a></p>
<p><em>CallArgLabel</em> :<br />
¬†¬† <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a><sup>Label must correspond to the name of the called function argument at the given position. It can be omitted if parameter name and the name of the called function argument are equal.</sup></p>
</blockquote>
<p>A <em>call expression</em> calls a function. The syntax of a call expression is an <a href="spec/expressions/./index.html">expression</a>, followed by a parenthesized comma-separated list of call arguments. Call arguments are expressions, and must be labeled and provided in the order specified in the <a href="spec/expressions/../items/functions/index.html">function definition</a>. If the function eventually returns, then the expression completes.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

    pub fn demo(self) {
        let ann: address = 0xaa
        let bob: address = 0xbb
        self.transfer(from: ann, to: bob, 25)
    }

    pub fn transfer(self, from: address, to: address, _ val: u256) {}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-expressions"><a class="header" href="#tuple-expressions">Tuple expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleExpression</em> :<br />
¬†¬† <code>(</code> <em>TupleElements</em><sup>?</sup> <code>)</code></p>
<p><em>TupleElements</em> :<br />
¬†¬† ( <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>,</code> )<sup>+</sup> <a href="spec/expressions/./index.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>A <em>tuple expression</em> constructs <a href="spec/expressions/../type_system/types/tuple.html">tuple values</a>.</p>
<p>The syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the <em>tuple initializer operands</em>. The number of tuple initializer operands is the <em>arity</em> of the constructed tuple.</p>
<p>1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a parenthetical expression.</p>
<p>Tuple expressions without any tuple initializer operands produce the unit tuple.</p>
<p>For other tuple expressions, the first written tuple initializer operand initializes the field <code>item0</code> and subsequent operands initializes the next highest field.</p>
<p>For example, in the tuple expression <code>(true, false, 1)</code>, <code>true</code> initializes the value of the field <code>item0</code>, <code>false</code> field <code>item1</code>, and <code>1</code> field <code>item2</code>.</p>
<p>Examples of tuple expressions and their types:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Type</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>()</code> (unit)</td></tr>
<tr><td><code>(0, 4)</code></td><td><code>(u256, u256)</code></td></tr>
<tr><td><code>(true, )</code></td><td><code>(bool, )</code></td></tr>
<tr><td><code>(true, -1, 1)</code></td><td><code>(bool, i256, u256)</code></td></tr>
</tbody></table>
</div>
<p>A tuple field can be accessed via an <a href="spec/expressions/./attribute.html">attribute expression</a>.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
    pub fn bar() {
        // Creating a tuple via a tuple expression
        let some_tuple: (u256, bool) = (1, false)

        // Accessing the first tuple field via the `item0` field
        baz(input: some_tuple.item0)
    }
    pub fn baz(input: u256) {}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-expressions"><a class="header" href="#list-expressions">List expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ListExpression</em> :<br />
¬†¬† <code>[</code> <em>ListElements</em><sup>?</sup> <code>]</code></p>
<p><em>ListElements</em> :<br />
¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> (<code>,</code> <a href="spec/expressions/./index.html"><em>Expression</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>A <em>list expression</em> constructs <a href="spec/expressions/../type_system/types/array.html">array values</a>.</p>
<p>The syntax for list expressions is a parenthesized, comma separated list of expressions, called the <em>list initializer operands</em>. The number of list initializer operands must be equal to the static size of the array type. The types of all list initializer operands must conform to the type of the array.</p>
<p>Examples of tuple expressions and their types:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Type</th></tr></thead><tbody>
<tr><td><code>[1, self.get_number()]</code></td><td><code>u256[2]</code></td></tr>
<tr><td><code>[true, false, false]</code></td><td><code>bool[3]</code></td></tr>
</tbody></table>
</div>
<p>An array item can be accessed via an <a href="spec/expressions/./indexing.html">index expression</a>.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

    fn get_val3() -&gt; u256 {
        return 3
    }

    pub fn baz() {
        let val1: u256 = 2
        // A list expression
        let foo: Array&lt;u256, 3&gt; = [1, val1, get_val3()]
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-expressions"><a class="header" href="#struct-expressions">Struct expressions</a></h1>
<p>TBW</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-expressions"><a class="header" href="#index-expressions">Index expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IndexExpression</em> :<br />
¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>[</code> <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>]</code></p>
</blockquote>
<p><a href="spec/expressions/../type_system/types/array.html">Array</a> and <a href="spec/expressions/../type_system/types/map.html">Map</a> types can be indexed by by writing a square-bracket-enclosed expression after them. For arrays, the type of the index key has to be <code>u256</code> whereas for <a href="spec/expressions/../type_system/types/map.html">Map</a> types it has to be equal to the key type of the map.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

    balances: Map&lt;address, u256&gt;


    pub fn baz(mut self, mut values: Array&lt;u256, 10&gt;) {
        // Assign value at slot 5
        values[5] = 1000
        // Read value at slot 5
        let val1: u256 = values[5]

        // Assign value for address zero
        self.balances[address(0)] = 10000

        // Read balance of address zero
        let bal: u256 = self.balances[address(0)]
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-expressions"><a class="header" href="#attribute-expressions">Attribute expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AttributeExpression</em> :<br />
¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>.</code> <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a></p>
</blockquote>
<p>An attribute expression evaluates to the location of an attribute of a <a href="spec/expressions/../type_system/types/struct.html">struct</a>, <a href="spec/expressions/../type_system/types/tuple.html">tuple</a> or <a href="spec/expressions/../type_system/types/contract.html">contract</a>.</p>
<p>The syntax for an attribute expression is an expression, then a <code>.</code> and finally an identifier.</p>
<p>Examples:</p>
<pre><code class="language-fe">struct Point {
    pub x: u256
    pub y: u256
}

contract Foo {
    some_point: Point
    some_tuple: (bool, u256)

    fn get_point() -&gt; Point {
        return Point(x: 100, y: 500)
    }

    pub fn baz(some_point: Point, some_tuple: (bool, u256)) {
        // Different examples of attribute expressions
        let bool_1: bool = some_tuple.item0
        let x1: u256 = some_point.x
        let point1: u256 = get_point().x
        let point2: u256 = some_point.x
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-expressions"><a class="header" href="#name-expressions">Name expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>NameExpression</em> :<br />
¬†¬† <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a></p>
</blockquote>
<p>A <em>name expression</em> resolves to a local variable.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
    pub fn baz(foo: u256) {
        // name expression resolving to the value of `foo`
        foo
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-expressions"><a class="header" href="#path-expressions">Path expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathExpression</em> :<br />
¬†¬† <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a> ( <code>::</code> <a href="spec/expressions/../lexical_structure/identifiers.html">IDENTIFIER</a> )<sup>*</sup></p>
</blockquote>
<p>A <em>name expression</em> resolves to a local variable.</p>
<p>Example:</p>
<pre><code class="language-fe ignore">contract Foo {
    pub fn baz() {
        // CONST_VALUE is defined in another module `my_mod`.
        let foo: u32 = my_mod::CONST_VALUE
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literal-expressions"><a class="header" href="#literal-expressions">Literal expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LiteralExpression</em> :<br />
¬†¬† | <a href="spec/expressions/../lexical_structure/tokens.html#string-literals">STRING_LITERAL</a><br />
¬†¬† | <a href="spec/expressions/../lexical_structure/tokens.html#integer-literals">INTEGER_LITERAL</a><br />
¬†¬† | <a href="spec/expressions/../lexical_structure/tokens.html#boolean-literals">BOOLEAN_LITERAL</a></p>
</blockquote>
<p>A <em>literal expression</em> consists of one of the <a href="spec/expressions/../lexical_structure/tokens.html#literals">literal</a> forms described earlier.
It directly describes a number, string or boolean value.</p>
<pre><code class="language-fe ignore">&quot;hello&quot;   // string type
5         // integer type
true      // boolean type
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ArithmeticExpression</em> :<br />
¬†¬†¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>+</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>-</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>*</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>/</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>%</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>**</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&amp;</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>|</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>^</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&lt;&lt;</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&gt;&gt;</code> <a href="spec/expressions/./index.html"><em>Expression</em></a></p>
</blockquote>
<p>Binary operators expressions are all written with <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a>.
This table summarizes the behavior of arithmetic and logical binary operators on
primitive types.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Integer</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Addition</td></tr>
<tr><td><code>-</code></td><td>Subtraction</td></tr>
<tr><td><code>*</code></td><td>Multiplication</td></tr>
<tr><td><code>/</code></td><td>Division*</td></tr>
<tr><td><code>%</code></td><td>Remainder</td></tr>
<tr><td><code>**</code></td><td>Exponentiation</td></tr>
<tr><td><code>&amp;</code></td><td>Bitwise AND</td></tr>
<tr><td><code>|</code></td><td>Bitwise OR</td></tr>
<tr><td><code>^</code></td><td>Bitwise XOR</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Left Shift</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Right Shift</td></tr>
</tbody></table>
</div>
<p>* Integer division rounds towards zero.</p>
<p>Here are examples of these operators being used.</p>
<pre><code class="language-fe ignore">3 + 6 == 9
6 - 3 == 3
2 * 3 == 6
6 / 3 == 2
5 % 4 == 1
2 ** 4 == 16
12 &amp; 25 == 8
12 | 25 == 29
12 ^ 25 == 21
212 &lt;&lt; 1 == 424
212 &gt;&gt; 1 == 106
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ComparisonExpression</em> :<br />
¬†¬† ¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>==</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>!=</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&gt;</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&lt;</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&gt;=</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>&lt;=</code> <a href="spec/expressions/./index.html"><em>Expression</em></a></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>Equal</td></tr>
<tr><td><code>!=</code></td><td>Not equal</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal to</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal to</td></tr>
</tbody></table>
</div>
<p>Here are examples of the comparison operators being used.</p>
<pre><code class="language-fe ignore">123 == 123
23 != -12
12 &gt; 11
11 &gt;= 11
11 &lt; 12
11 &lt;= 11
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BooleanExpression</em> :<br />
¬†¬†¬†¬† <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>or</code> <a href="spec/expressions/./index.html"><em>Expression</em></a><br />
¬†¬† | <a href="spec/expressions/./index.html"><em>Expression</em></a> <code>and</code> <a href="spec/expressions/./index.html"><em>Expression</em></a></p>
</blockquote>
<p>The operators <code>or</code> and <code>and</code> may be applied to operands of boolean type. The <code>or</code> operator denotes logical 'or', and the <code>and</code> operator denotes logical 'and'.</p>
<p>Example:</p>
<pre><code class="language-fe">const x: bool = false or true // true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>UnaryExpression</em> :<br />
¬†¬†¬†¬† <code>not</code> <a href="spec/expressions/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <code>-</code> <a href="spec/expressions/../expressions/index.html"><em>Expression</em></a><br />
¬†¬† | <code>~</code> <a href="spec/expressions/../expressions/index.html"><em>Expression</em></a></p>
</blockquote>
<p>The unary operators are used to negate expressions. The unary <code>-</code> (minus) operator yields the negation of its numeric argument. The unary <code>~</code> (invert) operator yields the <em>bitwise</em> inversion of its integer argument. The unary <code>not</code> operator yields the inversion of its boolean argument.</p>
<p>Example:</p>
<pre><code class="language-fe">fn f() {
  let x: bool = not true  // false
  let y: i256 = -1
  let z: i256 = i256(~1)  // -2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Every variable, item, and value in a Fe program has a type. The _ of a
<em>value</em> defines the interpretation of the memory holding it and the operations
that may be performed on the value.</p>
<p>Built-in types are tightly integrated into the language, in nontrivial ways
that are not possible to emulate in user-defined types. User-defined types have
limited capabilities.</p>
<p>The list of types is:</p>
<ul>
<li>Data types
<ul>
<li>Base types:
<ul>
<li><a href="spec/type_system/types/boolean.html">Boolean</a> ‚Äî <code>true</code> or <code>false</code></li>
<li><a href="spec/type_system/types/address.html">Address</a> - Ethereum address</li>
<li><a href="spec/type_system/types/numeric.html">Numeric</a> ‚Äî integer</li>
</ul>
</li>
<li>Reference types:
<ul>
<li>Sequence types
<ul>
<li><a href="spec/type_system/types/tuple.html">Tuple</a></li>
<li><a href="spec/type_system/types/array.html">Array</a></li>
<li><a href="spec/type_system/types/string.html">String</a></li>
<li><a href="spec/type_system/types/struct.html">Struct</a></li>
<li><a href="spec/type_system/types/enum.html">Enum</a></li>
</ul>
</li>
<li><a href="spec/type_system/types/map.html">Map</a></li>
</ul>
</li>
</ul>
</li>
<li>Other types:
<ul>
<li><a href="spec/type_system/types/unit.html">Unit</a></li>
<li><a href="spec/type_system/types/contract.html">Contract</a></li>
<li><a href="spec/type_system/types/function.html">Function</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-type"><a class="header" href="#boolean-type">Boolean type</a></h1>
<p>The <code>bool</code> type is a data type which can be either <code>true</code> or <code>false</code>.</p>
<p>Example:</p>
<pre><code>let x: bool = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-types"><a class="header" href="#contract-types">Contract types</a></h1>
<p>An <em>contract type</em> is the type denoted by the name of an <a href="spec/type_system/types/../../items/contracts.html"><code>contract</code> item</a>.</p>
<p>A value of a given contract type carries the contract's public interface as
attribute functions. A new contract value can be created by either casting
an address to a contract type or by creating a new contract using the type
attribute functions <code>create</code> or <code>create2</code>.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
    pub fn get_my_num() -&gt; u256 {
        return 42
    }
}

contract FooFactory {
    pub fn create2_foo(mut ctx: Context) -&gt; address {
        // `0` is the value being sent and `52` is the address salt
        let foo: Foo = Foo.create2(ctx, 0, 52)
        return address(foo)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h1>
<p>The unsigned integer types consist of:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td></tr>
<tr><td><code>u256</code></td><td>0</td><td>2<sup>256</sup>-1</td></tr>
</tbody></table>
</div>
<p>The signed two's complement integer types consist of:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td></tr>
<tr><td><code>i256</code></td><td>-(2<sup>255</sup>)</td><td>2<sup>255</sup>-1</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleType</em> :<br />
¬†¬† ¬†¬† <code>(</code> <code>)</code><br />
¬†¬† | <code>(</code> ( <a href="spec/type_system/types/./index.html"><em>Type</em></a> <code>,</code> )<sup>+</sup> <a href="spec/type_system/types/./index.html"><em>Type</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<p><em>Tuple types</em> are a family of structural types<sup class="footnote-reference"><a href="#1">1</a></sup> for heterogeneous lists of other types.</p>
<p>The syntax for a tuple type is a parenthesized, comma-separated list of types.</p>
<p>A tuple type has a number of fields equal to the length of the list of types.
This number of fields determines the <em>arity</em> of the tuple.
A tuple with <code>n</code> fields is called an <em>n-ary tuple</em>.
For example, a tuple with 2 fields is a 2-ary tuple.</p>
<p>Fields of tuples are named using increasing numeric names matching their position in the list of types.
The first field is <code>item0</code>.
The second field is <code>item1</code>.
And so on.
The type of each field is the type of the same position in the tuple's list of types.</p>
<p>For convenience and historical reasons, the tuple type with no fields (<code>()</code>) is often called <em>unit</em> or <em>the unit type</em>.
Its one value is also called <em>unit</em> or <em>the unit value</em>.</p>
<p>Some examples of tuple types:</p>
<ul>
<li><code>()</code> (also known as the <em>unit</em> or <em>zero-sized type</em>)</li>
<li><code>(u8, u8)</code></li>
<li><code>(bool, i32)</code></li>
<li><code>(i32, bool)</code> (different type from the previous example)</li>
</ul>
<p>Values of this type are constructed using a <a href="spec/type_system/types/../../expressions/tuple.html">tuple expression</a>.
Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to.
Tuple fields can be accessed via an <a href="spec/type_system/types/../../expressions/attribute.html">attribute expression</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Structural types are always equivalent if their internal types are equivalent.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-types"><a class="header" href="#array-types">Array types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ArrayType</em> :<br />
¬†¬† Array&lt;<a href="spec/type_system/types/./index.html"><em>Type</em></a>, <em>INTEGER_LITERAL</em>&gt;</p>
</blockquote>
<p>An array is a fixed-size sequence of <code>N</code> elements of type <code>T</code>. The array type
is written as <code>Array&lt;T, N&gt;</code>. The size is an integer literal.</p>
<p>Arrays are either stored in storage or memory but are never stored directly on the stack.</p>
<p>Examples:</p>
<pre><code class="language-fe">contract Foo {
  // An array in storage
  bar: Array&lt;u8, 10&gt;

  fn do_something() {
    // An array in memory
    let values: Array&lt;u256, 3&gt; = [10, 100, 100]
  }
}
</code></pre>
<p>All elements of arrays are always initialized, and access to an array is
always bounds-checked in safe methods and operators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-types"><a class="header" href="#struct-types">Struct types</a></h1>
<p>A <em>struct type</em> is the type denoted by the name of an <a href="spec/type_system/types/../../items/structs.html"><code>struct</code> item</a>.
A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the
<em>fields</em> of the type.</p>
<p>New instances of a <code>struct</code> can be constructed with a <a href="spec/type_system/types/../../expressions/struct.html">struct expression</a>.</p>
<p>Struct types are either stored in storage or memory but are never stored directly on the stack.</p>
<p>Examples:</p>
<pre><code class="language-fe">struct Rectangle {
  pub width: u256
  pub length: u256
}

contract Example {
  // A Rectangle in storage
  area: Rectangle

  fn do_something() {
    let length: u256 = 20
    // A rectangle in memory
    let square: Rectangle = Rectangle(width: 10, length)
  }
}
</code></pre>
<p>All fields of struct types are always initialized.</p>
<p>The data layout of a <code>struct</code> is not part of its external API and may be changed in any release.</p>
<p>The fields of a <code>struct</code> may be qualified by <a href="spec/type_system/types/../../items/visibility_and_privacy.html">visibility modifiers</a>, to allow
access to data in a struct outside a module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-types"><a class="header" href="#enum-types">Enum types</a></h1>
<p>An <em>enum type</em> is the type denoted by the name of an <a href="spec/type_system/types/../../items/enums.html"><code>enum</code> item</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-type"><a class="header" href="#address-type">Address Type</a></h1>
<p>The <code>address</code> type represents a 20 byte Ethereum address.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Example {
  // An address in storage
  someone: address

  fn do_something() {
    // A plain address (not part of a tuple, struct etc) remains on the stack
    let dai_contract: address = 0x6b175474e89094c44da98b954eedeac495271d0f
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-type"><a class="header" href="#map-type">Map type</a></h1>
<p>The type <code>Map&lt;K, V&gt;</code> is used to associate key values with data.</p>
<p>The following types can be used as key:</p>
<ul>
<li><a href="spec/type_system/types/unit.html">unit type</a></li>
<li><a href="spec/type_system/types/boolean.html">boolean type</a></li>
<li><a href="spec/type_system/types/address.html">address type</a></li>
<li><a href="spec/type_system/types/numeric.html">numeric types</a></li>
</ul>
<p>The values can be of any type including other maps, <a href="spec/type_system/types/struct.html">structs</a>, <a href="spec/type_system/types/tuple.html">tuples</a> or <a href="spec/type_system/types/array.html">arrays</a>.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
    bar: Map&lt;address, Map&lt;address, u256&gt;&gt;
    baz: Map&lt;address, Map&lt;u256, bool&gt;&gt;

    pub fn read_bar(self, a: address, b: address) -&gt; u256 {
        return self.bar[a][b]
    }

    pub fn write_bar(mut self, a: address, b: address, value: u256) {
        self.bar[a][b] = value
    }

    pub fn read_baz(self, a: address, b: u256) -&gt; bool {
        return self.baz[a][b]
    }

    pub fn write_baz(mut self, a: address, b: u256, value: bool) {
        self.baz[a][b] = value
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-type"><a class="header" href="#string-type">String Type</a></h1>
<p>A value of type <code>String&lt;N&gt;</code> represents a sequence of unsigned bytes with the assumption that the data is valid UTF-8.</p>
<p>The <code>String&lt;N&gt;</code> type is generic over a constant value that has to be an integer literal. That value <code>N</code> constraints the maximum number of bytes that are available for storing the string's characters.</p>
<p>Note that the value of <code>N</code> does not restrict the type to hold exactly that number of bytes at all times which means that a type such as <code>String&lt;10&gt;</code> can hold a short word such as <code>&quot;fox&quot;</code> but it can not hold a full sentence such as <code>&quot;The brown fox jumps over the white fence&quot;</code>.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {

  fn bar() {
    let single_byte_string: String&lt;1&gt; = &quot;a&quot;
    let longer_string: String&lt;100&gt; = &quot;foo&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-type"><a class="header" href="#unit-type">Unit type</a></h1>
<p>TBW</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-types"><a class="header" href="#function-types">Function Types</a></h1>
<p>TBW</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-layout"><a class="header" href="#data-layout">Data Layout</a></h1>
<p>There are three places where data can be stored on the EVM:</p>
<ul>
<li><strong>stack</strong>: 256-bit values placed on the stack that are loaded using <code>DUP</code> operations.</li>
<li><strong>storage</strong>: 256-bit address space where 256-bit values can be stored. Accessing higher
storage slots does not increase gas cost.</li>
<li><strong>memory</strong>: 256-bit address space where 256-bit values can be stored. Accessing higher
memory slots increases gas cost.</li>
</ul>
<p>Each <a href="spec/data_layout/../type_system/types/index.html">data type</a> can be stored in these locations. How data is stored is
described in this section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack"><a class="header" href="#stack">Stack</a></h1>
<p>The following can be stored on the stack:</p>
<ul>
<li>base type values</li>
<li>pointers to reference type values</li>
</ul>
<p>The size of each value stored on the stack must not exceed 256 bits. Since all base types are less
than or equal to 256 bits in size, we store them on the stack. Pointers to values stored in memory or storage may also be stored on the stack.</p>
<p>Example:</p>
<pre><code class="language-fe">fn f() {
    let foo: u256 = 42 // foo is stored on the stack
    let bar: Array&lt;u256, 100&gt; = [0; 100] // bar is a memory pointer stored on the stack
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>All data types can be stored in storage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-size-values-in-storage"><a class="header" href="#constant-size-values-in-storage">Constant size values in storage</a></h1>
<p>Storage pointers for constant size values are determined at compile time.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Cats {
   population: u256 // assigned a static location by the compiler
}
</code></pre>
<p>The value of a base type in storage is found by simply loading the value from storage at the
given pointer.</p>
<p>To find an element inside of a sequence type, the relative location of the element is added to the
given pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps-in-storage"><a class="header" href="#maps-in-storage">Maps in storage</a></h1>
<p>Maps are not assigned pointers, because they do not have a location in storage. They are instead
assigned a nonce that is used to derive the location of keyed values during runtime.</p>
<p>Example:</p>
<pre><code class="language-fe">contract Foo {
  bar: Map&lt;address, u256&gt; // bar is assigned a static nonce by the compiler
  baz: Map&lt;address, Map&lt;address, u256&gt;&gt; // baz is assigned a static nonce by the compiler
}
</code></pre>
<p>The expression <code>bar[0x00]</code> would resolve to the hash of both bar's nonce and the key value
.i.e. <code>keccak256(&lt;bar nonce&gt;, 0x00)</code>. Similarly, the expression <code>baz[0x00][0x01]</code> would resolve to
a nested hash i.e. <code>keccak256(keccak256(&lt;baz nonce&gt;, 0x00), 0x01)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-to_mem-function"><a class="header" href="#the-to_mem-function">The <code>to_mem</code> function</a></h1>
<p>Reference type values can be copied from storage and into memory using the <code>to_mem</code> function.</p>
<p>Example:</p>
<pre><code class="language-fe ignore">let my_array_var: Array&lt;u256, 10&gt; = self.my_array_field.to_mem()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>Only sequence types can be stored in memory.</p>
<p>The first memory slot (<code>0x00</code>) is used to keep track of the lowest available memory slot. Newly
allocated segments begin at the value given by this slot. When more memory has been allocated,
the value stored in <code>0x00</code> is increased.</p>
<p>We do not free memory after it is allocated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-types-in-memory"><a class="header" href="#sequence-types-in-memory">Sequence types in memory</a></h1>
<p>Sequence type values may exceed the 256-bit stack slot size, so we store them in memory and
reference them using pointers kept on the stack.</p>
<p>Example:</p>
<pre><code class="language-fe">fn f() {
    let foo: Array&lt;u256, 100&gt; = [0; 100] // foo is a pointer that references 100 * 256 bits in memory.
}
</code></pre>
<p>To find an element inside of a sequence type, the relative location of the element is added to the
given pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You <em>can</em> contribute to Fe! </p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to contribute:</a></h2>
<h3 id="1-reporting-or-fixing-issues"><a class="header" href="#1-reporting-or-fixing-issues">1. Reporting or fixing issues.</a></h3>
<p>If you find problems with Fe you can report them to the development team on the project <a href="https://github.com/ethereum/fe">Github</a>.
You are also welcome to work on existing issues, especially any tagged <code>good first issue</code> on the project issue board.</p>
<h3 id="2-improving-the-docs"><a class="header" href="#2-improving-the-docs">2. Improving the docs.</a></h3>
<p>We always appreciate improvements to the project documentation. This could be fixing any bugs you find, adding some detail to a description or explanation or developing a new user guide.</p>
<p>To add to the docs you can fork the Fe Github repository and make updates in the <code>/docs</code> directory. You can build and serve locally using <code>mdbook build &amp;&amp; mdbook serve</code>. Then, when you are happy with your changes you can raise a pull request to the main repository.</p>
<h3 id="3-developing-fe"><a class="header" href="#3-developing-fe">3. Developing Fe</a></h3>
<p>You are also welcome to work on Fe itself. There are many opportunities to help build the language, for example working on the compiler or the language specification, adding tests or developing tooling. </p>
<p>It is a good idea to connect with the existing Fe community to find out what are the priority areas that need attention and to discuss your idea in context before putting time into it. You can find Fe developers on the <a href="https://discord.gg/yCT6NYBb">Discord</a> or you can use the <a href="https://github.com/ethereum/fe/issues">Github issue board</a>.</p>
<blockquote>
<p><strong>Please note</strong> that there has been a substantial amount of work done on the <code>fe-v2</code> branch of the repository that includes breaking changes. When merged <code>fe-v2</code> will revert new contributions based on <code>master</code>. </p>
<p>To make your work v2 ready you can build off the <code>fe-v2</code> branch. It is recommended to seek out issues tagged <code>v2</code> in the Github Issue board.</p>
</blockquote>
<h3 id="4-community-engagement"><a class="header" href="#4-community-engagement">4. Community engagement</a></h3>
<p>We appreciate help answering questions on the Discord and other platforms such as Stack Exchange or Twitter.</p>
<blockquote>
<p>Please note that this project has a <a href="code_of_conduct.html">Code of Conduct</a>. By participating in this project ‚Äî in the issues, pull requests, or Discord channel ‚Äî you agree to abide by its terms.</p>
</blockquote>
<h2 id="processes"><a class="header" href="#processes">Processes</a></h2>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting issues</a></h3>
<p>To report an issue, please use the <a href="https://github.com/ethereum/fe/issues">Github issue board</a>. When reporting issues, please mention the following details:</p>
<ul>
<li>Fe version.</li>
<li>your operating system.</li>
<li>the steps required to reproduce the issue</li>
<li>actual vs expected behaviour</li>
<li>any error messages or relevant logs</li>
<li>the specific source code where the issue originates</li>
</ul>
<p>The appropriate place for technical discussions about the language itself is the Fe <a href="https://discord.gg/ywpkAXFjZH">Discord</a>.</p>
<h3 id="rasing-pull-requests"><a class="header" href="#rasing-pull-requests">Rasing Pull Requests</a></h3>
<p>Please <a href="https://docs.github.com/en/get-started/quickstart/fork-a-repo">fork the Fe repository</a> and raise <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request">pull requests</a> against the <code>master</code> branch.</p>
<p>Your commit messages should be concise and explain the changes made. Your pull request description should explain why the changes were made and list the specific changes. If you have to pull in changes from <code>master</code> to your fork (e.g. to resolve merge conflicts), please use <code>git rebase</code> rather than <code>git merge</code>.</p>
<p>New features should be accompanied by appropriate tests.</p>
<p>Finally, please make sure you respect the coding style for this project.</p>
<p>Thank you for contributing to Fe!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h1>
<p><a href="https://github.com/ethereum/fe/releases">üñ•Ô∏è Download Binaries</a>
<a href="https://github.com/ethereum/fe/tree/master/spec">üìÑ Draft Spec</a>
<a href="https://github.com/ethereum/fe#getting-started">‚ÑπÔ∏è Getting Started</a></p>
<p>Fe is moving fast. Read up on all the latest improvements.</p>
<h2 id="0260-zircon-2023-11-03"><a class="header" href="#0260-zircon-2023-11-03">0.26.0 &quot;Zircon&quot; (2023-11-03)</a></h2>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>
<p>Give option to produce runtime bytecode as compilation artifact</p>
<p>Previously, the compiler could only produce the bytecode that is used
for the deployment of the contract. Now it can also produce the runtime
bytecode which is the bytecode that is saved to storage.</p>
<p>Being able to obtain the runtime bytecode is useful for contract
verification.</p>
<p>To obtain the runtime bytecode use the <code>runtime-bytecode</code> option
of the <code>--emit</code> flag (multiple options allowed).</p>
<p>Example Output:</p>
<ul>
<li>mycontract.bin (bytecode for deployment)</li>
<li>mycontract.runtime.bin (runtime bytecode) (<a href="https://github.com/ethereum/fe/issues/947">#947</a>)</li>
</ul>
</li>
<li>
<p>New <code>verify</code> command to verify onchain contracts against local source code.</p>
<p>People need to be able to verify that a deployed contract matches the source code
that the author claims was used to deploy it. Previously, there was no simple
way to achieve this.</p>
<p>These are the steps to verify a contract with the <code>verify</code> command:</p>
<ol>
<li>Obtain the project's source code locally.</li>
<li>Ensure it is the same source code that was used to deploy the contract. (e.g. check out a specific tag)</li>
<li>From the project directory run <code>fe verify &lt;contract-address&gt; &lt;json-rpc-url&gt;</code></li>
</ol>
<p>Example:</p>
<pre><code class="language-bash">$ fe verify 0xf0adbb9ed4135d1509ad039505bada942d18755f https://example-eth-mainnet-rpc.com
It's a match!‚ú®

Onchain contract:
Address: 0xf0adbb9ed4135d1509ad039505bada942d18755f
Bytecode: 0x60008..76b90

Local contract:
Contract name: SimpleDAO
Source file: /home/work/ef/simple_dao/fe_contracts/simpledao/src/main.fe
Bytecode: 0x60008..76b90

Hint: Run with --verbose to see the contract's source code.
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/948">#948</a>)</p>
</li>
</ul>
<h3 id="improved-documentation"><a class="header" href="#improved-documentation">Improved Documentation</a></h3>
<ul>
<li>Added a new page on EVM precompiles (<a href="https://github.com/ethereum/fe/issues/944">#944</a>)</li>
</ul>
<h2 id="0250-yoshiokaite-2023-10-26"><a class="header" href="#0250-yoshiokaite-2023-10-26">0.25.0 &quot;Yoshiokaite&quot; (2023-10-26)</a></h2>
<h3 id="features-1"><a class="header" href="#features-1">Features</a></h3>
<ul>
<li>
<p>Use the project root as default path for <code>fe test</code></p>
<p>Just run <code>fe test</code> from any directory of the project. (<a href="https://github.com/ethereum/fe/issues/913">#913</a>)</p>
</li>
<li>
<p>Completed <code>std::buf::MemoryBuffer</code> refactor. (<a href="https://github.com/ethereum/fe/issues/917">#917</a>)</p>
</li>
<li>
<p>Allow filtering tests to run via <code>fe test --filter &lt;some-filter</code></p>
<p>E.g. Running <code>fe test --filter foo</code> will run all tests that contain <code>foo</code> in their name. (<a href="https://github.com/ethereum/fe/issues/919">#919</a>)</p>
</li>
<li>
<p>Logs for successfully ran tests can be printed with the <code>--logs</code> parameter.</p>
<p>example: </p>
<pre><code>// test_log.fe

use std::evm::log0
use std::buf::MemoryBuffer

struct MyEvent {
  pub foo: u256
  pub baz: bool
  pub bar: u256
}

#test
fn test_log(mut ctx: Context) {
  ctx.emit(MyEvent(foo: 42, baz: false, bar: 26))
  unsafe { log0(buf: MemoryBuffer::new(len: 42)) }
}

</code></pre>
<pre><code>$ fe test --logs test_log.fe
executing 1 test in test_log:
  test_log ... passed

test_log produced the following logs:
  MyEvent emitted by 0x0000‚Ä¶002a with the following parameters [foo: 2a, baz: false, bar: 1a]
  Log { address: 0x000000000000000000000000000000000000002a, topics: [], data: b&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\0\0\0\0\0\0\0\0\0&quot; }


1 test passed; 0 tests failed; 1 test executed
</code></pre>
<p>Note: Logs are not collected for failing tests. (<a href="https://github.com/ethereum/fe/issues/933">#933</a>)</p>
</li>
<li>
<p>Adds 'functions' section to docs with information on <code>self</code> and <code>Context</code>. (<a href="https://github.com/ethereum/fe/issues/937">#937</a>)</p>
</li>
</ul>
<h3 id="bugfixes"><a class="header" href="#bugfixes">Bugfixes</a></h3>
<ul>
<li>
<p>Yul codegen was failing to include string literals used in test assertions. This resulted in a compiler error.</p>
<p>Example:</p>
<pre><code>#test
fn foo() {
    assert false, &quot;oops&quot;
}
</code></pre>
<p>The example code above was failing to compile, but now it compiles and executes as expected. (<a href="https://github.com/ethereum/fe/issues/926">#926</a>)</p>
</li>
</ul>
<h3 id="improved-documentation-1"><a class="header" href="#improved-documentation-1">Improved Documentation</a></h3>
<ul>
<li>Added a new tutorial: Open Auction (<a href="https://github.com/ethereum/fe/issues/930">#930</a>)</li>
</ul>
<h2 id="0240-xenotime-2023-08-10"><a class="header" href="#0240-xenotime-2023-08-10">0.24.0 &quot;Xenotime&quot; (2023-08-10)</a></h2>
<h3 id="features-2"><a class="header" href="#features-2">Features</a></h3>
<ul>
<li>
<p>Added support for project manifests and project dependencies.</p>
<p>Example:</p>
<pre><code>my_project
‚îú‚îÄ‚îÄ fe.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.fe
</code></pre>
<pre><code># fe.toml
name = &quot;my_project&quot;
version = &quot;1.0&quot;

[dependencies]
my_lib = { path = &quot;../path/to/my_lib&quot;, version = &quot;1.0&quot; }
my_other_lib = &quot;../path/to/my_other_lib&quot;
</code></pre>
<p>Note: The current implementation supports circular dependencies. (<a href="https://github.com/ethereum/fe/issues/908">#908</a>)</p>
</li>
</ul>
<h3 id="performance-improvements"><a class="header" href="#performance-improvements">Performance improvements</a></h3>
<ul>
<li><code>MemoryBuffer</code> now allocates an extra 31 bytes. This removes the need for runtime checks and bitshifting needed to ensure safe writing to a <code>MemoryBuffer</code>'s region. (<a href="https://github.com/ethereum/fe/issues/898">#898</a>)</li>
</ul>
<h3 id="improved-documentation-2"><a class="header" href="#improved-documentation-2">Improved Documentation</a></h3>
<ul>
<li>Link to vs-code extension in Quickstart Guide (<a href="https://github.com/ethereum/fe/issues/910">#910</a>)</li>
</ul>
<h2 id="0230-wiluite-2023-06-01"><a class="header" href="#0230-wiluite-2023-06-01">0.23.0 &quot;Wiluite&quot; (2023-06-01)</a></h2>
<h3 id="features-3"><a class="header" href="#features-3">Features</a></h3>
<ul>
<li>
<p>Fixed an issue where generic parameters that were <code>mut</code> could not be satisfied at callsite.</p>
<p>For instance, the following code would previously cause a compile error but now works as expected:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Runner {
  pub fn run&lt;T: Computable&gt;(self, mut _ val: T) -&gt; u256 {
    return val.compute(val: 1000)
  }
}

contract Example {
  pub fn run_test(self) {
    let runner: Runner = Runner();
    let mut mac: Mac = Mac();

    assert runner.run(mac) == 1001
  }
}
<span class="boring">}</span></code></pre></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/865">#865</a>)</p>
</li>
<li>
<p>The <code>ctx</code> parameter can now be passed into test functions.</p>
<p>example:</p>
<pre><code>#test
fn my_test(ctx: Context) {
    assert ctx.block_number() == 0
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/880">#880</a>)</p>
</li>
<li>
<p>The following has been added to the standard library:</p>
<p><strong>Memory buffer abstraction</strong></p>
<p>example:</p>
<pre><code>use std::buf::{MemoryBuffer, MemoryBufferReader, MemoryBufferWriter}
use std::traits::Max

#test
fn test_buf_rw() {
    let mut buf: MemoryBuffer = MemoryBuffer::new(len: 161) 
    let mut writer: MemoryBufferWriter = buf.writer()
    let mut reader: MemoryBufferReader = buf.reader()

    writer.write(value: 42)
    writer.write(value: 42)
    writer.write(value: 26)
    writer.write(value: u8(26))
    writer.write(value: u256::max())
    writer.write(value: u128::max())
    writer.write(value: u64::max())
    writer.write(value: u32::max())
    writer.write(value: u16::max())
    writer.write(value: u8::max())
    writer.write(value: u8(0))

    assert reader.read_u256() == 42
    assert reader.read_u256() == 42
    assert reader.read_u256() == 26
    assert reader.read_u8() == 26
    assert reader.read_u256() == u256::max()
    assert reader.read_u128() == u128::max()
    assert reader.read_u64() == u64::max()
    assert reader.read_u32() == u32::max()
    assert reader.read_u16() == u16::max()
    assert reader.read_u8() == u8::max()
    assert reader.read_u8() == 0
}
</code></pre>
<p><strong>Precompiles</strong></p>
<p>example:</p>
<pre><code>use std::precompiles
use std::buf::{MemoryBuffer, MemoryBufferReader, MemoryBufferWriter}

#test
fn test_ec_recover() {
    let result: address = precompiles::ec_recover(
        hash: 0x456e9aea5e197a1f1af7a3e85a3212fa4049a3ba34c2289b4c860fc0b0c64ef3,
        v: 28,
        r: 0x9242685bf161793cc25603c231bc2f568eb630ea16aa137d2664ac8038825608,
        s: 0x4f8ae3bd7535248d0bd448298cc2e2071e56992d0774dc340c368ae950852ada
    )

    assert result == address(0x7156526fbd7a3c72969b54f64e42c10fbb768c8a)
}
</code></pre>
<p><strong><code>ctx.raw_call()</code></strong></p>
<p>example:</p>
<pre><code>use std::buf::{
    RawCallBuffer,
    MemoryBufferReader, 
    MemoryBufferWriter
}
use std::evm

contract Foo {
    pub unsafe fn __call__() {
        if evm::call_data_load(offset: 0) == 42 {
            evm::mstore(offset: 0, value: 26)
            evm::return_mem(offset: 0, len: 32)
        } else if evm::call_data_load(offset: 0) == 26 {
            revert
        }
    }
}

#test
fn test_raw_call(mut ctx: Context) {
    let foo: Foo = Foo.create(ctx, 0)

    let mut buf: RawCallBuffer = RawCallBuffer::new(
        input_len: 32, 
        output_len: 32
    )
    let mut writer: MemoryBufferWriter = buf.writer()

    writer.write(value: 42)
    assert ctx.raw_call(addr: address(foo), value: 0, buf)
  
    let mut reader: MemoryBufferReader = buf.reader()
    assert reader.read_u256() == 26

    assert not ctx.raw_call(addr: address(foo), value: 0, buf)
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/885">#885</a>)</p>
</li>
</ul>
<h3 id="bugfixes-1"><a class="header" href="#bugfixes-1">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed an ICE when using aggregate types with aggregate type fields in public functions</p>
<p>This code would previously cause an ICE:</p>
<pre><code class="language-fe">struct Tx {
  pub data: Array&lt;u8, 320&gt;
}

contract Foo {
  pub fn bar(mut tx: Tx) {}
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/867">#867</a>)</p>
</li>
<li>
<p>Fixed a regression where the compiler would not reject a method call on a struct in storage.</p>
<p>E.g. the follwing code should be rejected as it is missing a <code>to_mem()</code> call:</p>
<pre><code>struct Bar {
    pub x: u256

    pub fn get_x(self) -&gt; u256{
        return self.x
    }
}

contract Foo {
    bar: Bar

    pub fn __init__(mut self) {
        self.bar = Bar( x: 2 )
    }
    fn yay(self) {
        self.bar.get_x()
    }
}
</code></pre>
<p>The compiler will now reject the code and suggest a <code>to_mem()</code> before calling<code>get_x()</code>. (<a href="https://github.com/ethereum/fe/issues/881">#881</a>)</p>
</li>
</ul>
<h2 id="0220-vulcanite-2023-04-05"><a class="header" href="#0220-vulcanite-2023-04-05">0.22.0 &quot;Vulcanite&quot; (2023-04-05)</a></h2>
<p>This is the first non-alpha release of Fe. Read our <a href="https://blog.fe-lang.org/posts/beyond-alpha-preparing-fe-for-the-future/">announcement</a> for more details.</p>
<h3 id="features-4"><a class="header" href="#features-4">Features</a></h3>
<ul>
<li>
<p>Support for tests.</p>
<p>example:</p>
<pre><code>#test
fn my_test() {
    assert 26 + 16 == 42
}
</code></pre>
<p>Tests can be executed using the <code>test</code> subcommand.</p>
<p>example:</p>
<p><code>$ fe test foo.fe</code> (<a href="https://github.com/ethereum/fe/issues/807">#807</a>)</p>
</li>
<li>
<p>Fixed broken trait orphan rule</p>
<p>Fe has an orphan rule for Traits similar to Rust's that requires
that either the trait or the type that we are implementing the trait for
are located in the same ingot as the <code>impl</code>. This rule was implemented
incorrectly so that instead of requiring them to be in the same ingot,
they were required to be in the same module. This change fixes this
so that the orphan rule is enforced correctly.
(<a href="https://github.com/ethereum/fe/issues/863">#863</a>)</p>
</li>
<li>
<p><code>address</code> values can now be specified with a number literal, with no explicit
cast. So instead of <code>let t: address = address(0xfe)</code>, one can now write
<code>let t: address = 0xfe</code>. This also means that it's possible to define <code>const</code>
addresses: <code>const SOME_KNOWN_CONTRACT: address = 0xfefefefe</code>
(<a href="https://github.com/ethereum/fe/issues/864">#864</a>)</p>
</li>
</ul>
<h3 id="bugfixes-2"><a class="header" href="#bugfixes-2">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed resolving of generic arguments to associated functions.</p>
<p>For example, this code would previously crash the compiler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
  // This function doesn't take self
  pub fn run_static&lt;T: Computable&gt;(_ val: T) -&gt; u256 {
    return val.compute(val: 1000)
  }
...

// Invoking it would previously crash the compiler
Runner::run_static(Mac())
...
<span class="boring">}</span></code></pre></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/861">#861</a>)</p>
</li>
</ul>
<h3 id="improved-documentation-3"><a class="header" href="#improved-documentation-3">Improved Documentation</a></h3>
<ul>
<li>Changed the Deployment tutorial to use foundry and the Sepolia network (<a href="https://github.com/ethereum/fe/issues/853">#853</a>)</li>
</ul>
<h2 id="0210-alpha-2023-02-28"><a class="header" href="#0210-alpha-2023-02-28">0.21.0-alpha (2023-02-28)</a></h2>
<h3 id="features-5"><a class="header" href="#features-5">Features</a></h3>
<ul>
<li>
<p>Support for <code>Self</code> type</p>
<p>With this change <code>Self</code> (with capital <code>S</code>) can be used to refer
to the enclosing type in contracts, structs, impls and traits.</p>
<p>E.g.</p>
<pre><code>trait Min {
  fn min() -&gt; Self;
}

impl Min for u8 {
  fn min() -&gt; u8 { // Both `u8` or `Self` are valid here
    return 0
  }
}
</code></pre>
<p>Usage: <code>u8::min()</code> (<a href="https://github.com/ethereum/fe/issues/803">#803</a>)</p>
</li>
<li>
<p>Added <code>Min</code> and <code>Max</code> traits to the std library.
The std library implements the traits for all numeric types.</p>
<p>Example</p>
<pre><code>use std::traits::{Min, Max}
...

assert u8::min() &lt; u8::max()
``` ([#836](https://github.com/ethereum/fe/issues/836))

</code></pre>
</li>
<li>
<p>Upgraded underlying solc compiler to version <code>0.8.18</code></p>
</li>
</ul>
<h3 id="bugfixes-3"><a class="header" href="#bugfixes-3">Bugfixes</a></h3>
<ul>
<li>the release contains minor bugfixes</li>
</ul>
<h2 id="0200-alpha-2022-12-05"><a class="header" href="#0200-alpha-2022-12-05">0.20.0-alpha (2022-12-05)</a></h2>
<h3 id="features-6"><a class="header" href="#features-6">Features</a></h3>
<ul>
<li>
<p>Removed the <code>event</code> type as well as the <code>emit</code> keyword.
Instead the <code>struct</code> type now automatically implements
the <code>Emittable</code> trait and can be emitted via <code>ctx.emit(..)</code>.</p>
<p>Indexed fields can be annotated via the <code>#indexed</code> attribute.</p>
<p>E.g.</p>
<pre><code>struct Signed {
    book_msg: String&lt;100&gt;
}

contract GuestBook {
    messages: Map&lt;address, String&lt;100&gt;&gt;

    pub fn sign(mut self, mut ctx: Context, book_msg: String&lt;100&gt;) {
        self.messages[ctx.msg_sender()] = book_msg
        ctx.emit(Signed(book_msg))
    }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/717">#717</a>)</p>
</li>
<li>
<p>Allow to call trait methods on types when trait is in scope</p>
<p>So far traits were only useful as bounds for generic functions.
With this change traits can also be used as illustrated with
the following example:</p>
<pre><code>trait Double {
  fn double(self) -&gt; u256;
}

impl Double for (u256, u256) {
  fn double(self) -&gt; u256 {
    return (self.item0 + self.item1) * 2
  }
}

contract Example {

  pub fn run_test(self) {
    assert (0, 1).double() == 2
  }
}
</code></pre>
<p>If a call turns out to be ambigious the compiler currently asks the
user to disambiguate via renaming. In the future we will likely
introduce a syntax to allow to disambiguate at the callsite. (<a href="https://github.com/ethereum/fe/issues/757">#757</a>)</p>
</li>
<li>
<p>Allow contract associated functions to be called via <code>ContractName::function_name()</code> syntax. (<a href="https://github.com/ethereum/fe/issues/767">#767</a>)</p>
</li>
<li>
<p>Add <code>enum</code> types and <code>match</code> statement.</p>
<p><code>enum</code> can now be defined, e.g.,</p>
<pre><code class="language-fe">pub enum MyEnum {
    Unit
    Tuple(u32, u256, bool)
  
    fn unit() -&gt; MyEnum {
        return MyEnum::Unit
    }
}
</code></pre>
<p>Also, <code>match</code> statement is introduced, e.g.,</p>
<pre><code class="language-fe ignore">pub fn eval_enum()  -&gt; u256{
    match MyEnum {
        MyEnum::Unit =&gt; { 
            return 0
        }
      
        MyEnum::Tuple(a, _, false) =&gt; {
            return u256(a)
        }
      
        MyEnum::Tuple(.., true) =&gt; {
            return u256(1)
        }
    }
}
</code></pre>
<p>For now, available patterns are restricted to </p>
<ul>
<li>Wildcard(<code>_</code>), which matches all patterns: <code>_</code></li>
<li>Named variable, which matches all patterns and binds the value to make the value usable in the arm. e.g., <code>a</code>, <code>b</code> and <code>c</code> in <code>MyEnum::Tuple(a, b, c)</code></li>
<li>Boolean literal(<code>true</code> and <code>false</code>)</li>
<li>Enum variant. e.g., <code>MyEnum::Tuple(a, b, c)</code></li>
<li>Tuple pattern. e.g., <code>(a, b, c)</code></li>
<li>Struct pattern. e.g., <code>MyStruct {x: x1, y: y1, b: true}</code> </li>
<li>Rest pattern(<code>..</code>), which matches the rest of the pattern. e.g., <code>MyEnum::Tuple(.., true)</code></li>
<li>Or pattern(|). e.g., MyEnum::Unit | MyEnum::Tuple(.., true)</li>
</ul>
<p>Fe compiler performs the exhaustiveness and usefulness checks for <code>match</code> statement.<br />
So the compiler will emit an error when all patterns are not covered or an unreachable arm are detected. (<a href="https://github.com/ethereum/fe/issues/770">#770</a>)</p>
</li>
<li>
<p>Changed comments to use <code>//</code> instead of <code>#</code> (<a href="https://github.com/ethereum/fe/issues/776">#776</a>)</p>
</li>
<li>
<p>Added the <code>mut</code> keyword, to mark things as mutable. Any variable or function parameter
not marked <code>mut</code> is now immutable.</p>
<pre><code class="language-fe">contract Counter {
    count: u256

    pub fn increment(mut self) -&gt; u256 {
        // `self` is mutable, so storage can be modified
        self.count += 1
        return self.count
    }
}

struct Point {
    pub x: u32
    pub y: u32

    pub fn add(mut self, _ other: Point) {
        self.x += other.x
        self.y += other.y

        // other.x = 1000 // ERROR: `other` is not mutable
    }
}

fn pointless() {
    let origin: Point = Point(x: 0, y: 0)
    // origin.x = 10 // ERROR: origin is not mutable

    let x: u32 = 10
    // x_coord = 100 // ERROR: `x_coord` is not mutable
    let mut y: u32 = 0
    y = 10 // OK

    let mut p: Point = origin // copies `origin`
    p.x = 10 // OK, doesn't modify `origin`

    let mut q: Point = p // copies `p`
    q.x = 100            // doesn't modify `p`

    p.add(q)
    assert p.x == 110
}
</code></pre>
<p>Note that, in this release, primitive type function parameters
can't be <code>mut</code>. This restriction might be lifted in a future release.</p>
<p>For example:</p>
<pre><code class="language-fe ignore">fn increment(mut x: u256) { // ERROR: primitive type parameters can't be mut
    x += 1
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/777">#777</a>)</p>
</li>
<li>
<p>The contents of the <code>std::prelude</code> module (currently just the <code>Context</code> struct)
are now automatically <code>use</code>d by every module, so <code>use std::context::Context</code> is
no longer required. (<a href="https://github.com/ethereum/fe/issues/779">#779</a>)</p>
</li>
<li>
<p>When the Fe compiler generates a JSON ABI file for a contract, the
&quot;stateMutability&quot; field for each function now reflects whether the function can
read or modify chain or contract state, based on the presence or absence of the
<code>self</code> and <code>ctx</code> parameters, and whether those parameters are <code>mut</code>able.</p>
<p>If a function doesn't take <code>self</code> or <code>ctx</code>, it's &quot;pure&quot;.
If a function takes <code>self</code> or <code>ctx</code> immutably, it can read state but not mutate
state, so it's a &quot;view&quot;
If a function takes <code>mut self</code> or <code>mut ctx</code>, it can mutate state, and is thus
marked &quot;payable&quot;.</p>
<p>Note that we're following the convention set by Solidity for this field, which
isn't a perfect fit for Fe. The primary issue is that Fe doesn't currently
distinguish between &quot;payable&quot; and &quot;nonpayable&quot; functions; if you want a function
to revert when Eth is sent, you need to do it manually
(eg <code>assert ctx.msg_value() == 0</code>). (<a href="https://github.com/ethereum/fe/issues/783">#783</a>)</p>
</li>
<li>
<p>Trait associated functions</p>
<p>This change allows trait functions that do not take a <code>self</code> parameter.
The following demonstrates a possible trait associated function and its usage:</p>
<pre><code>trait Max {
  fn max(self) -&gt; u8;
}

impl Max for u8 {
  fn max() -&gt; u8 {
    return u8(255)
  }
}

contract Example {

  pub fn run_test(self) {
    assert u8::max() == 255
  }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/805">#805</a>)</p>
</li>
</ul>
<h3 id="bugfixes-4"><a class="header" href="#bugfixes-4">Bugfixes</a></h3>
<ul>
<li>
<p>Fix issue where calls to assiciated functions did not enforce visibility rules.</p>
<p>E.g the following code should be rejected but previously wasn't:</p>
<pre><code>struct Foo {
    fn do_private_things() {
    }
}

contract Bar {
    fn test() {
        Foo::do_private_things()
    }
}
</code></pre>
<p>With this change, the above code is now rejected because <code>do_private_things</code> is not <code>pub</code>. (<a href="https://github.com/ethereum/fe/issues/767">#767</a>)</p>
</li>
<li>
<p>Padding on <code>bytes</code> and <code>string</code> ABI types is zeroed out. (<a href="https://github.com/ethereum/fe/issues/769">#769</a>)</p>
</li>
<li>
<p>Ensure traits from other modules or even ingots can be implemented (<a href="https://github.com/ethereum/fe/issues/773">#773</a>)</p>
</li>
<li>
<p>Certain cases where the compiler would not reject pure functions
being called on instances are now properly rejected. (<a href="https://github.com/ethereum/fe/issues/775">#775</a>)</p>
</li>
<li>
<p>Reject calling <code>to_mem()</code> on primitive types in storage (<a href="https://github.com/ethereum/fe/issues/801">#801</a>)</p>
</li>
<li>
<p>Disallow importing private type via <code>use</code></p>
<p>The following was previously allowed but will now error:</p>
<p><code>use foo::PrivateStruct</code> (<a href="https://github.com/ethereum/fe/issues/815">#815</a>)</p>
</li>
</ul>
<h2 id="0191-alpha-sunstone-2022-07-06"><a class="header" href="#0191-alpha-sunstone-2022-07-06">0.19.1-alpha &quot;Sunstone&quot; (2022-07-06)</a></h2>
<h3 id="features-7"><a class="header" href="#features-7">Features</a></h3>
<ul>
<li>
<p>Support returning nested struct.</p>
<p>Example:</p>
<pre><code>pub struct InnerStruct {
    pub inner_s: String&lt;10&gt;
    pub inner_x: i256
}

pub struct NestedStruct {
    pub inner: InnerStruct
    pub outer_x: i256
}

contract Foo {
    pub fn return_nested_struct() -&gt; NestedStruct {
        ...
    }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/635">#635</a>)</p>
</li>
<li>
<p>Made some small changes to how the <code>Context</code> object is used.</p>
<ul>
<li><code>ctx</code> is not required when casting an address to a contract type. Eg <code>let foo: Foo = Foo(address(0))</code></li>
<li><code>ctx</code> is required when calling an external contract function that requires ctx</li>
</ul>
<p>Example:</p>
<pre><code class="language-fe ignore">use std::context::Context // see issue #679

contract Foo {
  pub fn emit_stuff(ctx: Context) {
    emit Stuff(ctx)  # will be `ctx.emit(Stuff{})` someday
  }
}
contract Bar {
  pub fn call_foo_emit_stuff(ctx: Context) {
    Foo(address(0)).emit_stuff(ctx)
  }
}
event Stuff {}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/703">#703</a>)</p>
</li>
<li>
<p>Braces! Fe has abandoned python-style significant whitespace in favor of the
trusty curly brace.</p>
<p>In addition, <code>elif</code> is now spelled <code>else if</code>, and the <code>pass</code>
statement no longer exists.</p>
<p>Example:</p>
<pre><code class="language-fe">pub struct SomeError {}

contract Foo {
  x: u8
  y: u16

  pub fn f(a: u8) -&gt; u8 {
    if a &gt; 10 {
      let x: u8 = 5
      return a + x
    } else if a == 0 {
      revert SomeError()
    } else {
      return a * 10
    }
  }

  pub fn noop() {}
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/707">#707</a>)</p>
</li>
<li>
<p>traits and generic function parameter</p>
<p>Traits can now be defined, e.g:</p>
<pre><code>trait Computable {
  fn compute(self, val: u256) -&gt; u256;
}
</code></pre>
<p>The mechanism to implement a trait is via an <code>impl</code> block e.g:</p>
<pre><code>struct Linux {
  pub counter: u256
  pub fn get_counter(self) -&gt; u256 {
    return self.counter
  }
  pub fn something_static() -&gt; u256 {
    return 5
  }
}

impl Computable for Linux {
  fn compute(self, val: u256) -&gt; u256 {
    return val + Linux::something_static() + self.get_counter()
  }
}
</code></pre>
<p>Traits can only appear as bounds for generic functions e.g.:</p>
<pre><code>struct Runner {

  pub fn run&lt;T: Computable&gt;(self, _ val: T) -&gt; u256 {
    return val.compute(val: 1000)
  }
}
</code></pre>
<p>Only <code>struct</code> functions (not <code>contract</code> functions) can have generic parameters.
The <code>run</code> method of <code>Runner</code> can be called with any type that implements <code>Computable</code> e.g.</p>
<pre><code>contract Example {

  pub fn generic_compute(self) {
    let runner: Runner = Runner();
    assert runner.run(Mac()) == 1001
    assert runner.run(Linux(counter: 10)) == 1015
  }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/710">#710</a>)</p>
</li>
<li>
<p>Generate artifacts for all contracts of an ingot, not just for contracts that are defined in <code>main.fe</code> (<a href="https://github.com/ethereum/fe/issues/726">#726</a>)</p>
</li>
<li>
<p>Allow using complex type as array element type.</p>
<p>Example:</p>
<pre><code>contract Foo {
    pub fn bar() -&gt; i256 {
        let my_array: Array&lt;Pair, 3&gt; = [Pair::new(1, 0), Pair::new(2, 0), Pair::new(3, 0)]

        let sum: i256 = 0
        for pair in my_array {
            sum += pair.x
        }

        return sum
    }
}

struct Pair {
    pub x: i256
    pub y: i256

    pub fn new(_ x: i256, _ y: i256) -&gt; Pair {
        return Pair(x, y)
    }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/730">#730</a>)</p>
</li>
<li>
<p>The <code>fe</code> CLI now has subcommands:</p>
<p><code>fe new myproject</code> - creates a new project structure
<code>fe check .</code>       - analyzes fe source code and prints errors
<code>fe build .</code>       - builds a fe project (<a href="https://github.com/ethereum/fe/issues/732">#732</a>)</p>
</li>
<li>
<p>Support passing nested struct types to public functions.</p>
<p>Example:</p>
<pre><code>pub struct InnerStruct {
    pub inner_s: String&lt;10&gt;
    pub inner_x: i256
}

pub struct NestedStruct {
    pub inner: InnerStruct
    pub outer_x: i256
}

contract Foo {
    pub fn f(arg: NestedStruct) {
        ...
    }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/733">#733</a>)</p>
</li>
<li>
<p>Added support for repeat expressions (<code>[VALUE; LENGTH]</code>).</p>
<p>e.g.</p>
<pre><code>let my_array: Array&lt;bool, 42&gt; = [bool; 42]
</code></pre>
<p>Also added checks to ensure array and struct types are initialized. These checks are currently performed at the declaration site, but will be loosened in the future. (<a href="https://github.com/ethereum/fe/issues/747">#747</a>)</p>
</li>
</ul>
<h3 id="bugfixes-5"><a class="header" href="#bugfixes-5">Bugfixes</a></h3>
<ul>
<li>
<p>Fix a bug that incorrect instruction is selected when the operands of a comp instruction are a signed type. (<a href="https://github.com/ethereum/fe/issues/734">#734</a>)</p>
</li>
<li>
<p>Fix issue where a negative constant leads to an ICE</p>
<p>E.g. the following code would previously crash the compiler but shouldn't:</p>
<pre><code>const INIT_VAL: i8 = -1
contract Foo {
  pub fn init_bar() {
    let x: i8 = INIT_VAL
  }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/745">#745</a>)</p>
</li>
<li>
<p>Fix a bug that causes ICE when nested if-statement has multiple exit point.</p>
<p>E.g. the following code would previously crash the compiler but shouldn't:</p>
<pre><code class="language-fe ignore"> pub fn foo(self) {
    if true {
        if self.something {
            return
        }
    }
    if true {
        if self.something {
            return
        }
    }
}
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/749">#749</a>)</p>
</li>
</ul>
<h2 id="0180-alpha-ruby-2022-05-27"><a class="header" href="#0180-alpha-ruby-2022-05-27">0.18.0-alpha &quot;Ruby&quot; (2022-05-27)</a></h2>
<h3 id="features-8"><a class="header" href="#features-8">Features</a></h3>
<ul>
<li>Added support for parsing of attribute calls with generic arguments (e.g. <code>foo.bar&lt;Baz&gt;()</code>). (<a href="https://github.com/ethereum/fe/issues/719">#719</a>)</li>
</ul>
<h3 id="bugfixes-6"><a class="header" href="#bugfixes-6">Bugfixes</a></h3>
<ul>
<li>Fix a regression where the <code>stateMutability</code> field would not be included in the generated ABI (<a href="https://github.com/ethereum/fe/issues/722">#722</a>)</li>
<li>Fix two regressions introduced in <code>0.17.0</code>
<ul>
<li>Properly lower right shift operation to yul's <code>sar</code> if operand is signed type</li>
<li>Properly lower negate operation to call <code>safe_sub</code> (<a href="https://github.com/ethereum/fe/issues/723">#723</a>)</li>
</ul>
</li>
</ul>
<h2 id="0170-alpha-quartz-2022-05-26"><a class="header" href="#0170-alpha-quartz-2022-05-26">0.17.0-alpha &quot;Quartz&quot; (2022-05-26)</a></h2>
<h3 id="features-9"><a class="header" href="#features-9">Features</a></h3>
<ul>
<li>
<p>Support for underscores in numbers to improve readability e.g. <code>100_000</code>.</p>
<p>Example</p>
<pre><code>    let num: u256 = 1000_000_000_000
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/149">#149</a>)</p>
</li>
<li>
<p>Optimized access of struct fields in storage (<a href="https://github.com/ethereum/fe/issues/249">#249</a>)</p>
</li>
<li>
<p>Unit type <code>()</code> is now ABI encodable (<a href="https://github.com/ethereum/fe/issues/442">#442</a>)</p>
</li>
<li>
<p>Temporary default <code>stateMutability</code> to <code>payable</code> in ABI</p>
<p>The ABI metadata that the compiler previously generated did not include the <code>stateMutability</code> field. This piece of information is important for tooling such as hardhat because it determines whether a function needs to be called with or without sending a transaction.</p>
<p>As soon as we have support for <code>mut self</code> and <code>mut ctx</code> we will be able to derive that information from the function signature. In the meantime we now default to <code>payable</code>. (<a href="https://github.com/ethereum/fe/issues/705">#705</a>)</p>
</li>
</ul>
<h3 id="bugfixes-7"><a class="header" href="#bugfixes-7">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed a crash caused by certain memory to memory assignments.</p>
<p>E.g. the following code would previously lead to a compiler crash:</p>
<pre><code>my_struct.x = my_struct.y
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/590">#590</a>)</p>
</li>
<li>
<p>Reject unary minus operation if the target type is an unsigned integer number.</p>
<p>Code below should be reject by <code>fe</code> compiler:</p>
<pre><code class="language-python">contract Foo:
    pub fn bar(self) -&gt; u32:
        let unsigned: u32 = 1
        return -unsigned

    pub fn foo():
        let a: i32 = 1
        let b: u32 = -a
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/651">#651</a>)</p>
</li>
<li>
<p>Fixed crash when passing a struct that contains an array</p>
<p>E.g. the following would previously result in a compiler crash:</p>
<pre><code>struct MyArray:
    pub x: Array&lt;i32, 2&gt;


contract Foo:
    pub fn bar(my_arr: MyArray):
        pass
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/681">#681</a>)</p>
</li>
<li>
<p>reject infinite size struct definitions.</p>
<p>Fe <code>structs</code> having infinite size due to recursive definitions were not rejected earlier and would cause ICE in the analyzer since they were not properly handled. Now <code>structs</code> having infinite size are properly identified by detecting cycles in the dependency graph of the struct field definitions and an error is thrown by the analyzer. (<a href="https://github.com/ethereum/fe/issues/682">#682</a>)</p>
</li>
<li>
<p>Return instead of revert when contract is called without data.</p>
<p>If a contract is called without data so that no function is invoked,
we would previously <code>revert</code> but that would leave us without a
way to send ETH to a contract so instead it will cause a <code>return</code> now. (<a href="https://github.com/ethereum/fe/issues/694">#694</a>)</p>
</li>
<li>
<p>Resolve compiler crash when using certain reserved YUL words as struct field names.</p>
<p>E.g. the following would previously lead to a compiler crash because <code>numer</code> is
a reserved keyword in YUL.</p>
<pre><code>struct Foo:
  pub number: u256

contract Meh:

  pub fn yay() -&gt; Foo:
    return Foo(number:2)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/709">#709</a>)</p>
</li>
</ul>
<h2 id="0160-alpha-2022-05-05"><a class="header" href="#0160-alpha-2022-05-05">0.16.0-alpha (2022-05-05)</a></h2>
<h3 id="features-10"><a class="header" href="#features-10">Features</a></h3>
<ul>
<li>Change static function call syntax from <code>Bar.foo()</code> to <code>Bar::foo()</code> (<a href="https://github.com/ethereum/fe/issues/241">#241</a>)</li>
<li>Added support for retrieving the base fee via <code>ctx.base_fee()</code> (<a href="https://github.com/ethereum/fe/issues/503">#503</a>)</li>
</ul>
<h3 id="bugfixes-8"><a class="header" href="#bugfixes-8">Bugfixes</a></h3>
<ul>
<li>Resolve functions on structs via path (e.g. <code>bi::ba::bums()</code>) (<a href="https://github.com/ethereum/fe/issues/241">#241</a>)</li>
</ul>
<h2 id="0150-alpha-2022-04-04"><a class="header" href="#0150-alpha-2022-04-04">0.15.0-alpha (2022-04-04)</a></h2>
<h3 id="features-11"><a class="header" href="#features-11">Features</a></h3>
<ul>
<li>
<p>Labels are now required on function arguments. Labels can be omitted if the
argument is a variable with a name that matches the label, or if the function
definition specifies that an argument should have no label. Functions often take
several arguments of the same type; compiler-checked labels can help prevent
accidentally providing arguments in the wrong order.</p>
<p>Example:</p>
<pre><code>contract CoolCoin:
  balance: Map&lt;address, i256&gt;
  loans: Map&lt;(address, address), i256&gt;

  pub fn demo(self, ann: address, bob: address):
    let is_loan: bool = false
    self.give(from: ann, to: bob, 100, is_loan)

  fn transfer(self, from sender: address, to recipient: address, _ val: u256, is_loan: bool):
    self.cred[sender] -= val
    self.cred[recipient] += val
    if is_loan:
      self.loans[(sender, recipient)] += val
</code></pre>
<p>Note that arguments must be provided in the order specified in the function
definition.</p>
<p>A parameter's label defaults to the parameter name, but can be changed by
specifying a different label to the left of the parameter name. Labels should be
clear and convenient for the caller, while parameter names are only used in the
function body, and can thus be longer and more descriptive.
In the example above, we choose to use <code>sender</code> and <code>recipient</code> as identifiers
in the body of <code>fn transfer</code>, but use labels <code>from:</code> and <code>to:</code>.</p>
<p>In cases where it's ideal to not have labels, e.g. if a function takes a single
argument, or if types are sufficient to differentiate between arguments, use <code>_</code>
to specify that a given parameter has no label. It's also fine to require labels
for some arguments, but not others.</p>
<p>Example:</p>
<pre><code>fn add(_ x: u256, _ y: u256) -&gt; u256:
  return x + y

contract Foo:
  fn transfer(self, _ to: address, wei: u256):
    pass

  pub fn demo(self):
    transfer(address(0), wei: add(1000, 42))
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/397">#397</a>)</p>
</li>
</ul>
<h3 id="bugfixes-9"><a class="header" href="#bugfixes-9">Bugfixes</a></h3>
<ul>
<li>The region of memory used to compute the slot of a storage map value was not being allocated. (<a href="https://github.com/ethereum/fe/issues/684">#684</a>)</li>
</ul>
<h2 id="0140-alpha-2022-03-02"><a class="header" href="#0140-alpha-2022-03-02">0.14.0-alpha (2022-03-02)</a></h2>
<h3 id="features-12"><a class="header" href="#features-12">Features</a></h3>
<ul>
<li>
<p>Events can now be defined outside of contracts.</p>
<p>Example:</p>
<pre><code>event Transfer:
    idx sender: address
    idx receiver: address
    value: u256

contract Foo:
    fn transferFoo(to: address, value: u256):
        emit Transfer(sender: msg.sender, receiver: to, value)

contract Bar:
    fn transferBar(to: address, value: u256):
        emit Transfer(sender: msg.sender, receiver: to, value)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/80">#80</a>)</p>
</li>
<li>
<p>The Fe standard library now includes a <code>std::evm</code> module, which provides functions that perform low-level evm operations.
Many of these are marked <code>unsafe</code>, and thus can only be used inside of an <code>unsafe</code> function or an <code>unsafe</code> block.</p>
<p>Example:</p>
<pre><code>use std::evm::{mstore, mload}

fn memory_shenanigans():
  unsafe:
    mstore(0x20, 42)
    let x: u256 = mload(0x20)
    assert x == 42
</code></pre>
<p>The global functions <code>balance</code> and <code>balance_of</code> have been removed; these can now be called as <code>std::evm::balance()</code>, etc.
The global function <code>send_value</code> has been ported to Fe, and is now available
as <code>std::send_value</code>.
(<a href="https://github.com/ethereum/fe/issues/629">#629</a>)</p>
</li>
<li>
<p>Support structs that have non-base type fields in storage.</p>
<p>Example:</p>
<pre><code>struct Point:
    pub x: u256
    pub y: u256

struct Bar:
    pub name: String&lt;3&gt;
    pub numbers: Array&lt;u256, 2&gt;
    pub point: Point
    pub something: (u256, bool)


contract Foo:
    my_bar: Bar

    pub fn complex_struct_in_storage(self) -&gt; String&lt;3&gt;:
        self.my_bar = Bar(
            name: &quot;foo&quot;,
            numbers: [1, 2],
            point: Point(x: 100, y: 200),
            something: (1, true),
        )

        # Asserting the values as they were set initially
        assert self.my_bar.numbers[0] == 1
        assert self.my_bar.numbers[1] == 2
        assert self.my_bar.point.x == 100
        assert self.my_bar.point.y == 200
        assert self.my_bar.something.item0 == 1
        assert self.my_bar.something.item1

        # We can change the values of the array
        self.my_bar.numbers[0] = 10
        self.my_bar.numbers[1] = 20
        assert self.my_bar.numbers[0] == 10
        assert self.my_bar.numbers[1] == 20
        # We can set the array itself
        self.my_bar.numbers = [1, 2]
        assert self.my_bar.numbers[0] == 1
        assert self.my_bar.numbers[1] == 2

        # We can change the values of the Point
        self.my_bar.point.x = 1000
        self.my_bar.point.y = 2000
        assert self.my_bar.point.x == 1000
        assert self.my_bar.point.y == 2000
        # We can set the point itself
        self.my_bar.point = Point(x=100, y=200)
        assert self.my_bar.point.x == 100
        assert self.my_bar.point.y == 200

        # We can change the value of the tuple
        self.my_bar.something.item0 = 10
        self.my_bar.something.item1 = false
        assert self.my_bar.something.item0 == 10
        assert not self.my_bar.something.item1
        # We can set the tuple itself
        self.my_bar.something = (1, true)
        assert self.my_bar.something.item0 == 1
        assert self.my_bar.something.item1

        return self.my_bar.name.to_mem()
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/636">#636</a>)</p>
</li>
<li>
<p>Features that read and modify state outside of contracts are now implemented on a struct
named &quot;Context&quot;. <code>Context</code> is included in the standard library and can be imported with
<code>use std::context::Context</code>. Instances of <code>Context</code> are created by calls to public functions
that declare it in the signature or by unsafe code.</p>
<p>Basic example:</p>
<pre><code>use std::context::Context

contract Foo:
    my_num: u256

    pub fn baz(ctx: Context) -&gt; u256:
        return ctx.block_number()

    pub fn bing(self, new_num: u256) -&gt; u256:
        self.my_num = new_num
        return self.my_num


contract Bar:

    pub fn call_baz(ctx: Context, foo_addr: address) -&gt; u256:
        # future syntax: `let foo = ctx.load&lt;Foo&gt;(foo_addr)`
        let foo: Foo = Foo(ctx, foo_addr)
        return foo.baz()

    pub fn call_bing(ctx: Context) -&gt; u256:
        # future syntax: `let foo = ctx.create&lt;Foo&gt;(0)`
        let foo: Foo = Foo.create(ctx, 0)
        return foo.bing(42)
</code></pre>
<p>Example with <code>__call__</code> and unsafe block:</p>
<pre><code>use std::context::Context
use std::evm

contract Foo:

    pub fn __call__():
        unsafe:
            # creating an instance of `Context` is unsafe
            let ctx: Context = Context()
            let value: u256 = u256(bar(ctx))

            # return `value`
            evm::mstore(0, value)
            evm::return_mem(0, 32)

    fn bar(ctx: Context) -&gt; address:
        return ctx.self_address()
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/638">#638</a>)</p>
</li>
<li>
<h1 id="features-13"><a class="header" href="#features-13">Features</a></h1>
<h2 id="support-local-constant"><a class="header" href="#support-local-constant">Support local constant</a></h2>
<p>Example:</p>
<pre><code class="language-python">contract Foo:
    pub fn bar():
        const LOCAL_CONST: i32 = 1
</code></pre>
<h2 id="support-constant-expression"><a class="header" href="#support-constant-expression">Support constant expression</a></h2>
<p>Example:</p>
<pre><code class="language-python">const GLOBAL: i32 = 8

contract Foo:
    pub fn bar():
        const LOCAL: i32 = GLOBAL * 8
</code></pre>
<h2 id="support-constant-generics-expression"><a class="header" href="#support-constant-generics-expression">Support constant generics expression</a></h2>
<p>Example:</p>
<pre><code class="language-python">const GLOBAL: u256= 8
const USE_GLOBAL: bool = false
type MY_ARRAY = Array&lt;i32, { GLOBAL / 4 }&gt;

contract Foo:
    pub fn bar():
        let my_array: Array&lt;i32, { GLOBAL if USE_GLOBAL else 4 }&gt;
</code></pre>
<h1 id="bug-fixes"><a class="header" href="#bug-fixes">Bug fixes</a></h1>
<h2 id="fix-ice-when-constant-type-is-mismatch"><a class="header" href="#fix-ice-when-constant-type-is-mismatch">Fix ICE when constant type is mismatch</a></h2>
<p>Example:</p>
<pre><code class="language-python">const GLOBAL: i32 = &quot;FOO&quot;

contract Foo:
    pub fn bar():
        let FOO: i32 = GLOBAL
</code></pre>
<h2 id="fix-ice-when-assigning-value-to-constant-twice"><a class="header" href="#fix-ice-when-assigning-value-to-constant-twice">Fix ICE when assigning value to constant twice</a></h2>
<p>Example:</p>
<pre><code class="language-python">const BAR: i32 = 1

contract FOO:
    pub fn bar():
        BAR = 10
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/649">#649</a>)</p>
</li>
<li>
<p>Argument label syntax now uses <code>:</code> instead of <code>=</code>. Example:</p>
<pre><code>struct Foo:
  x: u256
  y: u256

let x: MyStruct = MyStruct(x: 10, y: 11)
# previously:     MyStruct(x = 10, y = 11)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/665">#665</a>)</p>
</li>
<li>
<p>Support module-level <code>pub</code> modifier, now default visibility of items in a module is private.</p>
<p>Example:</p>
<pre><code class="language-python"># This constant can be used outside of the module.
pub const PUBLIC:i32 = 1

# This constant can NOT be used outside of the module.
const PRIVATE: i32 = 1
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/677">#677</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors"><a class="header" href="#internal-changes---for-fe-contributors">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<ul>
<li>Source files are now managed by a (salsa) <code>SourceDb</code>. A <code>SourceFileId</code> now corresponds to a salsa-interned <code>File</code> with a path. File content is a salsa input function. This is mostly so that the future (LSP) language server can update file content when the user types or saves, which will trigger a re-analysis of anything that changed.</li>
<li>An ingot's set of modules and dependencies are also salsa inputs, so that when the user adds/removes a file or dependency, analysis is rerun.</li>
<li>Standalone modules (eg a module compiled with <code>fe fee.fe</code>) now have a fake ingot parent. Each Ingot has an IngotMode (Lib, Main, StandaloneModule), which is used to disallow <code>ingot::whatever</code> paths in standalone modules, and to determine the correct root module file.</li>
<li><code>parse_module</code> now always returns an <code>ast::Module</code>, and thus a <code>ModuleId</code> will always exist for a source file, even if it contains fatal parse errors. If the parsing fails, the body will end with a <code>ModuleStmt::ParseError</code> node. The parsing will stop at all but the simplest of syntax errors, but this at least allows partial analysis of source file with bad syntax.</li>
<li><code>ModuleId::ast(db)</code> is now a query that parses the module's file on demand, rather than the AST being interned into salsa. This makes handling parse diagnostics cleaner, and removes the up-front parsing of every module at ingot creation time. (<a href="https://github.com/ethereum/fe/issues/628">#628</a>)</li>
</ul>
</li>
</ul>
<h2 id="0130-alpha-2022-01-31-0130-alpha-2022-01-31"><a class="header" href="#0130-alpha-2022-01-31-0130-alpha-2022-01-31">0.13.0-alpha (2022-01-31)## 0.13.0-alpha (2022-01-31)</a></h2>
<h3 id="features-14"><a class="header" href="#features-14">Features</a></h3>
<ul>
<li>
<p>Support private fields on structs</p>
<p>Public fields now need to be declared with the <code>pub</code> modifier, otherwise they default to private fields.
If a struct contains private fields it can not be constructed directly except from within the
struct itself. The recommended way is to implement a method <code>new(...)</code> as demonstrated in the
following example.</p>
<pre><code>struct House:
    pub price: u256
    pub size: u256
    vacant: bool

    pub fn new(price: u256, size: u256) -&gt; House
      return House(price=price, size=size, vacant=true)

contract Manager:

  house: House

  pub fn create_house(price: u256, size: u256):
    self.house = House::new(price, size)
    let can_access_price: u256 = self.house.price
    # can not access `self.house.vacant` because the field is private
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/214">#214</a>)</p>
</li>
<li>
<p>Support non-base type fields in structs</p>
<p>Support is currently limited in two ways:</p>
<ul>
<li>Structs with complex fields can not be returned from public functions</li>
<li>Structs with complex fields can not be stored in storage (<a href="https://github.com/ethereum/fe/issues/343">#343</a>)</li>
</ul>
</li>
<li>
<p>Addresses can now be explicitly cast to u256. For example:</p>
<pre><code>fn f(addr: address) -&gt; u256:
  return u256(addr)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/621">#621</a>)</p>
</li>
<li>
<p>A special function named <code>__call__</code> can now be defined in contracts.</p>
<p>The body of this function will execute in place of the standard dispatcher when the contract is called.</p>
<p>example (with intrinsics):</p>
<pre><code>contract Foo:
    pub fn __call__(self):
        unsafe:
            if __calldataload(0) == 1:
                __revert(0, 0)
            else:
                __return(0, 0)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/622">#622</a>)</p>
</li>
</ul>
<h3 id="bugfixes-10"><a class="header" href="#bugfixes-10">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed a crash that happend when using a certain unprintable ASCII char (<a href="https://github.com/ethereum/fe/issues/551">#551</a>)</p>
</li>
<li>
<p>The argument to <code>revert</code> wasn't being lowered by the compiler,
meaning that some <code>revert</code> calls would cause a compiler panic
in later stages. For example:</p>
<pre><code>const BAD_MOJO: u256 = 0xdeaddead

struct Error:
  code: u256

fn fail():
  revert Error(code = BAD_MOJO)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/619">#619</a>)</p>
</li>
<li>
<p>Fixed a regression where an empty list expression (<code>[]</code>) would lead to a compiler crash. (<a href="https://github.com/ethereum/fe/issues/623">#623</a>)</p>
</li>
<li>
<p>Fixed a bug where int array elements were not sign extended in their ABI encodings. (<a href="https://github.com/ethereum/fe/issues/633">#633</a>)</p>
</li>
</ul>
<h2 id="0120-alpha-2021-12-31-0120-alpha-2021-12-31"><a class="header" href="#0120-alpha-2021-12-31-0120-alpha-2021-12-31">0.12.0-alpha (2021-12-31)## 0.12.0-alpha (2021-12-31)</a></h2>
<h3 id="features-15"><a class="header" href="#features-15">Features</a></h3>
<ul>
<li>
<p>Added unsafe low-level &quot;intrinsic&quot; functions, that perform raw evm operations.
For example:</p>
<pre><code>fn foo():
  unsafe:
    __mtore(0, 5000)
    assert __mload(0) == 5000
</code></pre>
<p>The functions available are exactly those defined in yul's &quot;evm dialect&quot;:
https://docs.soliditylang.org/en/v0.8.11/yul.html#evm-dialect
but with a double-underscore prefix. Eg <code>selfdestruct</code> -&gt; <code>__selfdestruct</code>.</p>
<p>These are intended to be used for implementing basic standard library functionality,
and shouldn't typically be needed in normal contract code.</p>
<p>Note: some intrinsic functions don't return a value (eg <code>__log0</code>); using these
functions in a context that assumes a return value of unit type (eg <code>let x: () = __log0(a, b)</code>)
will currently result in a compiler panic in the yul compilation phase. (<a href="https://github.com/ethereum/fe/issues/603">#603</a>)</p>
</li>
<li>
<p>Added an out of bounds check for accessing array items.
If an array index is retrieved at an index that is not within
the bounds of the array it now reverts with <code>Panic(0x32)</code>. (<a href="https://github.com/ethereum/fe/issues/606">#606</a>)</p>
</li>
</ul>
<h3 id="bugfixes-11"><a class="header" href="#bugfixes-11">Bugfixes</a></h3>
<ul>
<li>
<p>Ensure ternary expression short circuit.</p>
<p>Example:</p>
<pre><code>contract Foo:

    pub fn bar(input: u256) -&gt; u256:
        return 1 if input &gt; 5 else revert_me()

    fn revert_me() -&gt; u256:
        revert
        return 0
</code></pre>
<p>Previous to this change, the code above would <strong>always</strong> revert no matter
which branch of the ternary expressions it would resolve to. That is because
both sides were evaluated and then one side was discarded. With this change,
only the branch that doesn't get picked won't get evaluated at all.</p>
<p>The same is true for the boolean operations <code>and</code> and <code>or</code>. (<a href="https://github.com/ethereum/fe/issues/488">#488</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-1"><a class="header" href="#internal-changes---for-fe-contributors-1">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<p>Added a globally available <em>dummy</em> std lib.</p>
<p>This library contains a single <code>get_42</code> function, which can be called using <code>std::get_42()</code>. Once
low-level intrinsics have been added to the language, we can delete <code>get_42</code> and start adding
useful code. (<a href="https://github.com/ethereum/fe/issues/601">#601</a>)</p>
</li>
</ul>
<h2 id="0110-alpha-karlite-2021-12-02"><a class="header" href="#0110-alpha-karlite-2021-12-02">0.11.0-alpha &quot;Karlite&quot; (2021-12-02)</a></h2>
<h3 id="features-16"><a class="header" href="#features-16">Features</a></h3>
<ul>
<li>
<p>Added support for multi-file inputs.</p>
<p><strong>Implementation details:</strong></p>
<p>Mostly copied Rust's crate system, but use the term <em>ingot</em> instead of crate.</p>
<p>Below is an example of an ingot's file tree, as supported by the current implementation.</p>
<pre><code>`-- basic_ingot
    `-- src
        |-- bar
        |   `-- baz.fe
        |-- bing.fe
        |-- ding
        |   |-- dang.fe
        |   `-- dong.fe
        `-- main.fe
</code></pre>
<p>There are still a few features that will be worked on over the coming months:</p>
<ul>
<li>source files accompanying each directory module (e.g. <code>my_mod.fe</code>)</li>
<li>configuration files and the ability to create library ingots</li>
<li>test directories</li>
<li>module-level <code>pub</code> modifier (all items in a module are public)</li>
<li><code>mod</code> statements (all fe files in the input tree are public modules)</li>
</ul>
<p>These things will be implemented in order of importance over the next few months. (<a href="https://github.com/ethereum/fe/issues/562">#562</a>)</p>
</li>
<li>
<p>The syntax for array types has changed to match other generic types.
For example, <code>u8[4]</code> is now written <code>Array&lt;u8, 4&gt;</code>. (<a href="https://github.com/ethereum/fe/issues/571">#571</a>)</p>
</li>
<li>
<p>Functions can now be defined on struct types. Example:</p>
<pre><code>struct Point:
  x: u64
  y: u64

  # Doesn't take `self`. Callable as `Point.origin()`.
  # Note that the syntax for this will soon be changed to `Point::origin()`.
  pub fn origin() -&gt; Point:
    return Point(x=0, y=0)

  # Takes `self`. Callable on a value of type `Point`.
  pub fn translate(self, x: u64, y: u64):
    self.x += x
    self.y += y

  pub fn add(self, other: Point) -&gt; Point:
    let x: u64 = self.x + other.x
    let y: u64 = self.y + other.y
    return Point(x, y)

  pub fn hash(self) -&gt; u256:
    return keccak256(self.abi_encode())

pub fn do_pointy_things():
  let p1: Point = Point.origin()
  p1.translate(5, 10)

  let p2: Point = Point(x=1, y=2)
  let p3: Point = p1.add(p2)

  assert p3.x == 6 and p3.y == 12
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/577">#577</a>)</p>
</li>
</ul>
<h3 id="bugfixes-12"><a class="header" href="#bugfixes-12">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed a rare compiler crash.</p>
<p>Example:</p>
<pre><code>let my_array: i256[1] = [-1 &lt;&lt; 1]
</code></pre>
<p>Previous to this fix, the given example would lead to an ICE. (<a href="https://github.com/ethereum/fe/issues/550">#550</a>)</p>
</li>
<li>
<p>Contracts can now <code>create</code> an instance of a contract defined later in a file.
This issue was caused by a weakness in the way we generated yul. (<a href="https://github.com/ethereum/fe/issues/596">#596</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-2"><a class="header" href="#internal-changes---for-fe-contributors-2">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<p>File IDs are now attached to <code>Span</code>s. (<a href="https://github.com/ethereum/fe/issues/587">#587</a>)</p>
</li>
<li>
<p>The fe analyzer now builds a dependency graph of source code &quot;items&quot; (functions, contracts, structs, etc).
This is used in the yulgen phase to determine which items are needed in the yul (intermediate representation)
output. Note that the yul output is still cluttered with utility functions that may or may not be needed by
a given contract. These utility functions are defined in the yulgen phase and aren't tracked in the dependency
graph, so it's not yet possible to filter out the unused functions. We plan to move the definition of many
of these utility functions into fe; when this happens they'll become part of the dependency graph and will only
be included in the yul output when needed.</p>
<p>The dependency graph will also enable future analyzer warnings about unused code. (<a href="https://github.com/ethereum/fe/issues/596">#596</a>)</p>
</li>
</ul>
<h2 id="0100-alpha-2021-10-31"><a class="header" href="#0100-alpha-2021-10-31">0.10.0-alpha (2021-10-31)</a></h2>
<h3 id="features-17"><a class="header" href="#features-17">Features</a></h3>
<ul>
<li>
<p>Support for module level constants for base types</p>
<p>Example:</p>
<pre><code>const TEN = 10

contract

  pub fn do_moon_math(self) -&gt; u256:
    return 4711 * TEN
</code></pre>
<p>The values of base type constants are always inlined. (<a href="https://github.com/ethereum/fe/issues/192">#192</a>)</p>
</li>
<li>
<p>Encode revert errors for ABI decoding as <code>Error(0x103)</code> not <code>Panic(0x99)</code> (<a href="https://github.com/ethereum/fe/issues/492">#492</a>)</p>
</li>
<li>
<p>Replaced <code>import</code> statements with <code>use</code> statements.</p>
<p>Example:</p>
<pre><code>use foo::{bar::*, baz as baz26}
</code></pre>
<p>Note: this only adds support for parsing <code>use</code> statements. (<a href="https://github.com/ethereum/fe/issues/547">#547</a>)</p>
</li>
<li>
<p>Functions can no be defined outside of contracts. Example:</p>
<pre><code>fn add_bonus(x: u256) -&gt; u256:
    return x + 10

contract PointTracker:
    points: Map&lt;address, u256&gt;

    pub fn add_points(self, user: address, val: u256):
        self.points[user] += add_bonus(val)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/566">#566</a>)</p>
</li>
<li>
<p>Implemented a <code>send_value(to: address, value_in_wei: u256)</code> function.</p>
<p>The function is similar to the <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5b28259dacf47fc208e03611eb3ba8eeaed63cc0/contracts/utils/Address.sol#L54-L59"><code>sendValue</code> function by OpenZeppelin</a> with the differences being that:</p>
<ol>
<li>
<p>It reverts with <code>Error(0x100)</code> instead of <code>Error(&quot;Address: insufficient balance&quot;)</code> to
safe more gas.</p>
</li>
<li>
<p>It uses <code>selfbalance()</code> instead of <code>balance(address())</code> to safe more gas</p>
</li>
<li>
<p>It reverts with <code>Error(0x101)</code> instead of <code>Error(&quot;Address: unable to send value, recipient may have reverted&quot;)</code> also to safe more gas. (<a href="https://github.com/ethereum/fe/issues/567">#567</a>)</p>
</li>
</ol>
</li>
<li>
<p>Added support for <code>unsafe</code> functions and <code>unsafe</code> blocks within functions.
Note that there's currently no functionality within Fe that requires the use
of <code>unsafe</code>, but we plan to add built-in <code>unsafe</code> functions that perform raw
evm operations which will only callable within an <code>unsafe</code> block or function. (<a href="https://github.com/ethereum/fe/issues/569">#569</a>)</p>
</li>
<li>
<p>Added <code>balance()</code> and <code>balance_of(account: address)</code> methods. (<a href="https://github.com/ethereum/fe/issues/572">#572</a>)</p>
</li>
<li>
<p>Added support for explicit casting between numeric types.</p>
<p>Example:</p>
<pre><code>let a: i8 = i8(-1)
let a1: i16 = i16(a)
let a2: u16 = u16(a1)

assert a2 == u16(65535)

let b: i8 = i8(-1)
let b1: u8 = u8(b)
let b2: u16 = u16(b1)

assert b2 == u16(255)
</code></pre>
<p>Notice that Fe allows casting between any two numeric types but does not allow
to change both the sign and the size of the type in one step as that would leave
room for ambiguity as the example above demonstrates. (<a href="https://github.com/ethereum/fe/issues/576">#576</a>)</p>
</li>
</ul>
<h3 id="bugfixes-13"><a class="header" href="#bugfixes-13">Bugfixes</a></h3>
<ul>
<li>
<p>Adjust numeric values loaded from memory or storage</p>
<p>Previous to this fix numeric values that were loaded from either memory or storage
were not properly loaded on the stack which could result in numeric values not
treated as intended.</p>
<p>Example:</p>
<pre><code>contract Foo:

    pub fn bar() -&gt; i8:
        let in_memory: i8[1] = [-3]
        return in_memory[0]
</code></pre>
<p>In the example above <code>bar()</code> would not return <code>-3</code> but <code>253</code> instead. (<a href="https://github.com/ethereum/fe/issues/524">#524</a>)</p>
</li>
<li>
<p>Propagate reverts from external contract calls.</p>
<p>Before this fix the following code to <code>should_revert()</code> or <code>should_revert2()</code>
would succeed even though it clearly should not.</p>
<pre><code>contract A:
  contract_b: B
  pub fn __init__(contract_b: address):
    self.contract_b = B(contract_b)

  pub fn should_revert():
    self.contract_b.fail()

  pub fn should_revert2():
    self.contract_b.fail_with_custom_error()

struct SomeError:
  pass

contract B:

  pub fn fail():
    revert

  pub fn fail_with_custom_error():
    revert SomeError()
</code></pre>
<p>With this fix the revert errors are properly passed upwards the call hierachy. (<a href="https://github.com/ethereum/fe/issues/574">#574</a>)</p>
</li>
<li>
<p>Fixed bug in left shift operation.</p>
<p>Example:</p>
<p>Let's consider the value <code>1</code> as an <code>u8</code> which is represented as
the following 256 bit item on the EVM stack <code>00..|00000001|</code>.
A left shift of <code>8</code> bits (<code>val &lt;&lt; 8</code>) turns that into <code>00..01|00000000|</code>.</p>
<p>Previous to this fix this resulted in the compiler taking <code>256</code> as the
value for the <code>u8</code> when clearly <code>256</code> is not even in the range of <code>u8</code>
anymore. With this fix the left shift operations was fixed to properly
&quot;clean up&quot; the result of the shift so that <code>00..01|00000000|</code> turns into
<code>00..00|00000000|</code>. (<a href="https://github.com/ethereum/fe/issues/575">#575</a>)</p>
</li>
<li>
<p>Ensure negation is checked and reverts with over/underflow if needed.</p>
<p>Example:</p>
<p>The minimum value for an <code>i8</code> is <code>-128</code> but the maximum value of an <code>i8</code>
is <code>127</code> which means that negating <code>-128</code> should lead to an overflow since
<code>128</code> does not fit into an <code>i8</code>. Before this fix, negation operations where
not checked for over/underflow resulting in returning the oversized value. (<a href="https://github.com/ethereum/fe/issues/578">#578</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-3"><a class="header" href="#internal-changes---for-fe-contributors-3">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<p>In the analysis stage, all name resolution (of variable names, function names,
type names, etc used in code) now happens via a single <code>resolve_name</code> pathway,
so we can catch more cases of name collisions and log more helpful error messages. (<a href="https://github.com/ethereum/fe/issues/555">#555</a>)</p>
</li>
<li>
<p>Added a new category of tests: differential contract testing.</p>
<p>Each of these tests is pased on a pair of contracts where one implementation
is written in Fe and the other one is written in Solidity. The implementations
should have the same public APIs and are assumed to always return identical
results given equal inputs. The inputs are randomly generated using <code>proptest</code>
and hence are expected to discover unknown bugs. (<a href="https://github.com/ethereum/fe/issues/578">#578</a>)</p>
</li>
</ul>
<h2 id="090-alpha-2021-09-29"><a class="header" href="#090-alpha-2021-09-29">0.9.0-alpha (2021-09-29)</a></h2>
<h3 id="features-18"><a class="header" href="#features-18">Features</a></h3>
<ul>
<li>
<p>The <code>self</code> variable is no longer implicitly defined in code blocks. It must now be declared
as the first parameter in a function signature.</p>
<p>Example:</p>
<pre><code>contract Foo:
    my_stored_num: u256

    pub fn bar(self, my_num: u256):
        self.my_stored_num = my_num

    pub fn baz(self):
        self.bar(my_pure_func())

    pub fn my_pure_func() -&gt; u256:
        return 42 + 26
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/520">#520</a>)</p>
</li>
<li>
<p>The analyzer now disallows defining a type, variable, or function whose
name conflicts with a built-in type, function, or object.</p>
<p>Example:</p>
<pre><code>error: type name conflicts with built-in type
‚îå‚îÄ compile_errors/shadow_builtin_type.fe:1:6
‚îÇ
1 ‚îÇ type u256 = u8
‚îÇ      ^^^^ `u256` is a built-in type
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/539">#539</a>)</p>
</li>
</ul>
<h3 id="bugfixes-14"><a class="header" href="#bugfixes-14">Bugfixes</a></h3>
<ul>
<li>Fixed cases where the analyzer would correctly reject code, but would panic instead of logging an error message. (<a href="https://github.com/ethereum/fe/issues/534">#534</a>)</li>
<li>Non-fatal parser errors (eg missing parentheses when defining a function that takes no arguments: <code>fn foo:</code>)
are no longer ignored if the semantic analysis stage succeeds. (<a href="https://github.com/ethereum/fe/issues/535">#535</a>)</li>
<li>Fixed issue #531 by adding a <code>$</code> to the front of lowered tuple names. (<a href="https://github.com/ethereum/fe/issues/546">#546</a>)</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-4"><a class="header" href="#internal-changes---for-fe-contributors-4">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Implemented pretty printing of Fe AST. (<a href="https://github.com/ethereum/fe/issues/540">#540</a>)</li>
</ul>
<h2 id="080-alpha-haxonite-2021-08-31"><a class="header" href="#080-alpha-haxonite-2021-08-31">0.8.0-alpha &quot;Haxonite&quot; (2021-08-31)</a></h2>
<h3 id="features-19"><a class="header" href="#features-19">Features</a></h3>
<ul>
<li>
<p>Support quotes, tabs and carriage returns in string literals and otherwise
restrict string literals to the printable subset of the ASCII table. (<a href="https://github.com/ethereum/fe/issues/329">#329</a>)</p>
</li>
<li>
<p>The analyzer now uses a query-based system, which fixes some shortcomings of the previous implementation.</p>
<ul>
<li>Types can now refer to other types defined later in the file.
Example:</li>
</ul>
<pre><code>type Posts = Map&lt;PostId, PostBody&gt;
type PostId = u256
type PostBody = String&lt;140&gt;
</code></pre>
<ul>
<li>Duplicate definition errors now show the location of the original definition.</li>
<li>The analysis of each function, type definition, etc happens independently, so an error in one
doesn't stop the analysis pass. This means fe can report more user errors in a single run of the compiler. (<a href="https://github.com/ethereum/fe/issues/468">#468</a>)</li>
</ul>
</li>
<li>
<p>Function definitions are now denoted with the keyword fn instead of def. (<a href="https://github.com/ethereum/fe/issues/496">#496</a>)</p>
</li>
<li>
<p>Variable declarations are now preceded by the <code>let</code> keyword. Example: <code>let x: u8 = 1</code>. (<a href="https://github.com/ethereum/fe/issues/509">#509</a>)</p>
</li>
<li>
<p>Implemented support for numeric unary invert operator (<code>~</code>) (<a href="https://github.com/ethereum/fe/issues/526">#526</a>)</p>
</li>
</ul>
<h3 id="bugfixes-15"><a class="header" href="#bugfixes-15">Bugfixes</a></h3>
<ul>
<li>
<p>Calling <code>self.__init__()</code> now results in a nice error instead of a panic in the yul compilation stage. (<a href="https://github.com/ethereum/fe/issues/468">#468</a>)</p>
</li>
<li>
<p>Fixed an issue where certain expressions were not being moved to the correct location. (<a href="https://github.com/ethereum/fe/issues/493">#493</a>)</p>
</li>
<li>
<p>Fixed an issue with a missing return statement not properly detected.</p>
<p>Previous to this fix, the following code compiles but it should not:</p>
<pre><code>contract Foo:
    pub fn bar(val: u256) -&gt; u256:
        if val &gt; 1:
            return 5
</code></pre>
<p>With this change, the compiler rightfully detects that the code is missing
a <code>return</code> or <code>revert</code> statement after the <code>if</code> statement since it is not
guaranteed that the path of execution always follows the arm of the <code>if</code> statement. (<a href="https://github.com/ethereum/fe/issues/497">#497</a>)</p>
</li>
<li>
<p>Fixed a bug in the analyzer which allowed tuple item accessor names with a leading 0,
resulting in an internal compiler error in a later pass. Example: <code>my_tuple.item001</code>.
These are now rejected with an error message. (<a href="https://github.com/ethereum/fe/issues/510">#510</a>)</p>
</li>
<li>
<p>Check call argument labels for function calls.</p>
<p>Previously the compiler would not check any labels that were used
when making function calls on <code>self</code> or external contracts.</p>
<p>This can be especially problematic if gives developers the impression
that they could apply function arguments in any order as long as they
are named which is <strong>not</strong> the case.</p>
<pre><code>contract Foo:

    pub fn baz():
        self.bar(val2=1, doesnt_even_exist=2)

    pub fn bar(val1: u256, val2: u256):
        pass
</code></pre>
<p>Code as the one above is now rightfully rejected by the compiler. (<a href="https://github.com/ethereum/fe/issues/517">#517</a>)</p>
</li>
</ul>
<h3 id="improved-documentation-4"><a class="header" href="#improved-documentation-4">Improved Documentation</a></h3>
<ul>
<li>
<p>Various improvements and bug fixes to both the content and layout of the specification. (<a href="https://github.com/ethereum/fe/issues/489">#489</a>)</p>
</li>
<li>
<p>Document all remaining statements and expressions in the spec.</p>
<p>Also added a CI check to ensure code examples in the documentation
are validated against the latest compiler. (<a href="https://github.com/ethereum/fe/issues/514">#514</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-5"><a class="header" href="#internal-changes---for-fe-contributors-5">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Separated Fe type traits between crates. (<a href="https://github.com/ethereum/fe/issues/485">#485</a>)</li>
</ul>
<h2 id="070-alpha-galaxite-2021-07-27"><a class="header" href="#070-alpha-galaxite-2021-07-27">0.7.0-alpha &quot;Galaxite&quot; (2021-07-27)</a></h2>
<h3 id="features-20"><a class="header" href="#features-20">Features</a></h3>
<ul>
<li>
<p>Enable the optimizer by default. The optimizer can still be disabled
by supplying <code>--optimize=false</code> as an argument. (<a href="https://github.com/ethereum/fe/issues/439">#439</a>)</p>
</li>
<li>
<p>The following checks are now performed while decoding data:</p>
<ul>
<li>The size of the encoded data fits within the size range known at compile-time.</li>
<li>Values are correctly padded.
<ul>
<li>unsigned integers, addresses, and bools are checked to have correct left zero padding</li>
<li>the size of signed integers are checked</li>
<li>bytes and strings are checked to have correct right padding</li>
</ul>
</li>
<li>Data section offsets are consistent with the size of preceding values in the data section.</li>
<li>The dynamic size of strings does not exceed their maximum size.</li>
<li>The dynamic size of byte arrays (<code>u8[n]</code>) is equal to the size of the array. (<a href="https://github.com/ethereum/fe/issues/440">#440</a>)</li>
</ul>
</li>
<li>
<p>Type aliases can now include tuples. Example:</p>
<pre><code>type InternetPoints = (address, u256)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/459">#459</a>)</p>
</li>
<li>
<p>Revert with custom errors</p>
<p>Example:</p>
<pre><code>struct PlatformError:
  code: u256

pub fn do_something():
  revert PlatformError(code=4711)
</code></pre>
<p>Error encoding <a href="https://docs.soliditylang.org/en/v0.8.4/abi-spec.html#errors">follows Solidity</a> which is based on <a href="https://github.com/ethereum/EIPs/issues/838">EIP-838</a>. This means that custom errors returned from Fe are fully compatible with Solidity. (<a href="https://github.com/ethereum/fe/issues/464">#464</a>)</p>
</li>
<li>
<ul>
<li>The builtin value <code>msg.sig</code> now has type <code>u256</code>.</li>
<li>Removed the <code>bytes[n]</code> type. The type <code>u8[n]</code> can be used in its placed and will be encoded as a dynamically-sized, but checked, bytes component. (<a href="https://github.com/ethereum/fe/issues/472">#472</a>)</li>
</ul>
</li>
<li>
<p>Encode certain reverts as panics.</p>
<p>With this change, the following reverts are encoded as <code>Panic(uint256)</code> with
the following panic codes:</p>
<ul>
<li><code>0x01</code>: An assertion that failed and did not specify an error message</li>
<li><code>0x11</code>: An arithmetic expression resulted in an over- or underflow</li>
<li><code>0x12</code>: An arithmetic expression divided or modulo by zero</li>
</ul>
<p>The panic codes are aligned with <a href="https://docs.soliditylang.org/en/v0.8.4/control-structures.html?highlight=Panic#panic-via-assert-and-error-via-require">the panic codes that Solidity uses</a>. (<a href="https://github.com/ethereum/fe/issues/476">#476</a>)</p>
</li>
</ul>
<h3 id="bugfixes-16"><a class="header" href="#bugfixes-16">Bugfixes</a></h3>
<ul>
<li>
<p>Fixed a crash when trying to access an invalid attribute on a string.</p>
<p>Example:</p>
<pre><code>contract Foo:

  pub fn foo():
    &quot;&quot;.does_not_exist
</code></pre>
<p>The above now yields a proper user error. (<a href="https://github.com/ethereum/fe/issues/444">#444</a>)</p>
</li>
<li>
<p>Ensure <code>String&lt;N&gt;</code> type is capitalized in error messages (<a href="https://github.com/ethereum/fe/issues/445">#445</a>)</p>
</li>
<li>
<p>Fixed ICE when using a static string that spans over multiple lines.</p>
<p>Previous to this fix, the following code would lead to a compiler crash:</p>
<pre><code>contract Foo:
    pub fn return_with_newline() -&gt; String&lt;16&gt;:
        return &quot;foo
        balu&quot;
</code></pre>
<p>The above code now works as intended. (<a href="https://github.com/ethereum/fe/issues/448">#448</a>)</p>
</li>
<li>
<p>Fixed ICE when using a tuple declaration and specifying a non-tuple type.
Fixed a second ICE when using a tuple declaration where the number of
target items doesn't match the number of items in the declared type. (<a href="https://github.com/ethereum/fe/issues/469">#469</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-6"><a class="header" href="#internal-changes---for-fe-contributors-6">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<ul>
<li>Cleaned up ABI encoding internals.</li>
<li>Improved yulc panic formatting. (<a href="https://github.com/ethereum/fe/issues/472">#472</a>)</li>
</ul>
</li>
</ul>
<h2 id="060-alpha-feldspar-2021-06-10"><a class="header" href="#060-alpha-feldspar-2021-06-10">0.6.0-alpha &quot;Feldspar&quot; (2021-06-10)</a></h2>
<h3 id="features-21"><a class="header" href="#features-21">Features</a></h3>
<ul>
<li>
<p>Support for <code>pragma</code> statement</p>
<p>Example: <code>pragma ^0.1.0</code> (<a href="https://github.com/ethereum/fe/issues/361">#361</a>)</p>
</li>
<li>
<p>Add support for tuple destructuring</p>
<p>Example:</p>
<pre><code>my_tuple: (u256, bool) = (42, true)
(x, y): (u256, bool) = my_tuple
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/376">#376</a>)</p>
</li>
<li>
<ol>
<li>Call expression can now accept generic arguments</li>
<li>Replace <code>stringN</code> to <code>String&lt;N&gt;</code></li>
</ol>
<p>Example:</p>
<pre><code>s: String&lt;10&gt; = String&lt;10&gt;(&quot;HI&quot;)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/379">#379</a>)</p>
</li>
<li>
<ul>
<li>Many analyzer errors now include helpful messages and underlined code.</li>
<li>Event and struct constructor arguments must now be labeled and in the order specified in the definition.</li>
<li>The analyzer now verifies that the left-hand side of an assignment is actually assignable. (<a href="https://github.com/ethereum/fe/issues/398">#398</a>)</li>
</ul>
</li>
<li>
<p>Types of integer literal are now inferred, rather than defaulting to <code>u256</code>.</p>
<pre><code>contract C:

  fn f(x: u8) -&gt; u16:
    y: u8 = 100   # had to use u8(100) before
    z: i8 = -129  # &quot;literal out of range&quot; error

    return 1000   # had to use `return u16(1000)` before

  fn g():
    self.f(50)
</code></pre>
<p>Similar inference is done for empty array literals. Previously, empty array
literals caused a compiler crash, because the array element type couldn't
be determined.</p>
<pre><code>contract C:
  fn f(xs: u8[10]):
    pass

  fn g():
    self.f([])
</code></pre>
<p>(Note that array length mismatch is still a type error, so this code won't
actually compile.) (<a href="https://github.com/ethereum/fe/issues/429">#429</a>)</p>
</li>
<li>
<p>The Map type name is now capitalized. Example:</p>
<pre><code>contract GuestBook:
    guests: Map&lt;address, String&lt;100&gt;&gt;
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/431">#431</a>)</p>
</li>
<li>
<p>Convert all remaining errors to use the new advanced error reporting system (<a href="https://github.com/ethereum/fe/issues/432">#432</a>)</p>
</li>
<li>
<p>Analyzer throws an error if <code>__init__</code> is not public. (<a href="https://github.com/ethereum/fe/issues/435">#435</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-7"><a class="header" href="#internal-changes---for-fe-contributors-7">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Refactored front-end &quot;not implemented&quot; errors into analyzer errors and removed questionable variants. Any panic is now considered to be a bug. (<a href="https://github.com/ethereum/fe/issues/437">#437</a>)</li>
</ul>
<h2 id="050-alpha-2021-05-27"><a class="header" href="#050-alpha-2021-05-27">0.5.0-alpha (2021-05-27)</a></h2>
<h3 id="features-22"><a class="header" href="#features-22">Features</a></h3>
<ul>
<li>
<p>Add support for hexadecimal/octal/binary numeric literals.</p>
<p>Example:</p>
<pre><code>value_hex: u256 = 0xff
value_octal: u256 = 0o77
value_binary: u256 = 0b11
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/333">#333</a>)</p>
</li>
<li>
<p>Added support for list expressions.</p>
<p>Example:</p>
<pre><code>values: u256[3] = [10, 20, 30]

# or anywhere else where expressions can be used such as in a call

sum: u256 = self.sum([10, 20, 30])
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/388">#388</a>)</p>
</li>
<li>
<p>Contracts, events, and structs can now be empty.</p>
<p>e.g.</p>
<pre><code>event MyEvent:
    pass

...

contract MyContract:
    pass

...

struct MyStruct:
    pass
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/406">#406</a>)</p>
</li>
<li>
<p>External calls can now handle dynamically-sized return types. (<a href="https://github.com/ethereum/fe/issues/415">#415</a>)</p>
</li>
</ul>
<h3 id="bugfixes-17"><a class="header" href="#bugfixes-17">Bugfixes</a></h3>
<ul>
<li>The analyzer will return an error if a tuple attribute is not of the form <code>item&lt;index&gt;</code>. (<a href="https://github.com/ethereum/fe/issues/401">#401</a>)</li>
</ul>
<h3 id="improved-documentation-5"><a class="header" href="#improved-documentation-5">Improved Documentation</a></h3>
<ul>
<li>Created a landing page for Fe at https://fe-lang.org (<a href="https://github.com/ethereum/fe/issues/394">#394</a>)</li>
<li>Provide a Quickstart chapter in Fe Guide (<a href="https://github.com/ethereum/fe/issues/403">#403</a>)</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-8"><a class="header" href="#internal-changes---for-fe-contributors-8">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>
<p>Using insta to validate Analyzer outputs. (<a href="https://github.com/ethereum/fe/issues/387">#387</a>)</p>
</li>
<li>
<p>Analyzer now disallows using <code>context.add_</code> methods to update attributes. (<a href="https://github.com/ethereum/fe/issues/392">#392</a>)</p>
</li>
<li>
<p><code>()</code> now represents a distinct type internally called the unit type, instead of an empty tuple.</p>
<p>The lowering pass now does the following: Valueless return statements are given a <code>()</code> value and
functions without a return value are given explicit <code>()</code> returns. (<a href="https://github.com/ethereum/fe/issues/406">#406</a>)</p>
</li>
<li>
<p>Add CI check to ensure fragment files always end with a new line (<a href="https://github.com/ethereum/fe/issues/4711">#4711</a>)</p>
</li>
</ul>
<h2 id="040-alpha-2021-04-28"><a class="header" href="#040-alpha-2021-04-28">0.4.0-alpha (2021-04-28)</a></h2>
<h3 id="features-23"><a class="header" href="#features-23">Features</a></h3>
<ul>
<li>
<p>Support for revert messages in assert statements</p>
<p>E.g</p>
<pre><code>assert a == b, &quot;my revert statement&quot;
</code></pre>
<p>The provided string is abi-encoded as if it were a call
to a function <code>Error(string)</code>. For example, the revert string <code>&quot;Not enough Ether provided.&quot;</code> returns the following hexadecimal as error return data:</p>
<pre><code>0x08c379a0                                                         // Function selector for Error(string)
0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
0x000000000000000000000000000000000000000000000000000000000000001a // String length
0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/288">#288</a>)</p>
</li>
<li>
<p>Added support for augmented assignments.</p>
<p>e.g.</p>
<pre><code>contract Foo:
    pub fn add(a: u256, b: u256) -&gt; u256:
        a += b
        return a

    pub fn sub(a: u256, b: u256) -&gt; u256:
        a -= b
        return a

    pub fn mul(a: u256, b: u256) -&gt; u256:
        a *= b
        return a

    pub fn div(a: u256, b: u256) -&gt; u256:
        a /= b
        return a

    pub fn mod(a: u256, b: u256) -&gt; u256:
        a %= b
        return a

    pub fn pow(a: u256, b: u256) -&gt; u256:
        a **= b
        return a

    pub fn lshift(a: u8, b: u8) -&gt; u8:
        a &lt;&lt;= b
        return a

    pub fn rshift(a: u8, b: u8) -&gt; u8:
        a &gt;&gt;= b
        return a

    pub fn bit_or(a: u8, b: u8) -&gt; u8:
        a |= b
        return a

    pub fn bit_xor(a: u8, b: u8) -&gt; u8:
        a ^= b
        return a

    pub fn bit_and(a: u8, b: u8) -&gt; u8:
        a &amp;= b
        return a
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/338">#338</a>)</p>
</li>
<li>
<p>A new parser implementation, which provides more helpful error messages
with fancy underlines and code context. (<a href="https://github.com/ethereum/fe/issues/346">#346</a>)</p>
</li>
<li>
<p>Added support for tuples with base type items.</p>
<p>e.g.</p>
<pre><code>contract Foo:
    my_num: u256

    pub fn bar(my_num: u256, my_bool: bool) -&gt; (u256, bool):
        my_tuple: (u256, bool) = (my_num, my_bool)
        self.my_num = my_tuple.item0
        return my_tuple
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/352">#352</a>)</p>
</li>
</ul>
<h3 id="bugfixes-18"><a class="header" href="#bugfixes-18">Bugfixes</a></h3>
<ul>
<li>
<p>Properly reject invalid emit (<a href="https://github.com/ethereum/fe/issues/211">#211</a>)</p>
</li>
<li>
<p>Properly tokenize numeric literals when they start with 0 (<a href="https://github.com/ethereum/fe/issues/331">#331</a>)</p>
</li>
<li>
<p>Reject non-string assert reasons as type error (<a href="https://github.com/ethereum/fe/issues/335">#335</a>)</p>
</li>
<li>
<p>Properly reject code that creates a circular dependency when using <code>create</code> or <code>create2</code>.</p>
<p>Example, the following code is now rightfully rejected because it tries to create an
instance of <code>Foo</code> from within the <code>Foo</code> contract itself.</p>
<pre><code>contract Foo:
  pub fn bar()-&gt;address:
    foo:Foo=Foo.create(0)

    return address(foo)
</code></pre>
<p>(<a href="https://github.com/ethereum/fe/issues/362">#362</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-9"><a class="header" href="#internal-changes---for-fe-contributors-9">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>AST nodes use <code>String</code>s instead of <code>&amp;str</code>s. This way we can perform incremental compilation on the AST. (<a href="https://github.com/ethereum/fe/issues/332">#332</a>)</li>
<li>Added support for running tests against solidity fixtures.
Also added tests that cover how solidity encodes revert reason strings. (<a href="https://github.com/ethereum/fe/issues/342">#342</a>)</li>
<li>Refactoring of binary operation type checking. (<a href="https://github.com/ethereum/fe/issues/347">#347</a>)</li>
</ul>
<h2 id="030-alpha-calamine-2021-03-24"><a class="header" href="#030-alpha-calamine-2021-03-24">0.3.0-alpha &quot;Calamine&quot; (2021-03-24)</a></h2>
<h3 id="features-24"><a class="header" href="#features-24">Features</a></h3>
<ul>
<li>
<p>Add over/underflow checks for multiplications of all integers (<a href="https://github.com/ethereum/fe/issues/271">#271</a>)</p>
</li>
<li>
<p>Add full support for empty Tuples. (<a href="https://github.com/ethereum/fe/issues/276">#276</a>)</p>
<p>All functions in Fe implicitly return an empty Tuple if they have no other return value.
However, before this change one was not able to use the empty Tuple syntax <code>()</code> explicitly.</p>
<p>With this change, all of these are treated equally:</p>
<pre><code>contract Foo:

  pub fn explicit_return_a1():
    return

  pub fn explicit_return_a2():
    return ()

  pub fn explicit_return_b1() -&gt;():
    return

  pub fn explicit_return_b2() -&gt;():
    return ()

  pub fn implicit_a1():
    pass

  pub fn implicit_a2() -&gt;():
    pass
</code></pre>
</li>
<li>
<p>The JSON ABI builder now supports structs as both input and output. (<a href="https://github.com/ethereum/fe/issues/296">#296</a>)</p>
</li>
<li>
<p>Make subsequently defined contracts visible.</p>
<p>Before this change:</p>
<pre><code># can't see Bar
contract Foo:
   ...
# can see Foo
contract Bar:
   ...
</code></pre>
<p>With this change the restriction is lifted and the following becomes possible. (<a href="https://github.com/ethereum/fe/issues/298">#298</a>)</p>
<pre><code>contract Foo:
    bar: Bar
    pub fn external_bar() -&gt; u256:
        return self.bar.bar()
contract Bar:
    foo: Foo
    pub fn external_foo() -&gt; u256:
        return self.foo.foo()
</code></pre>
</li>
<li>
<p>Perform checks for divison operations on integers (<a href="https://github.com/ethereum/fe/issues/308">#308</a>)</p>
</li>
<li>
<p>Support for msg.sig to read the function identifier. (<a href="https://github.com/ethereum/fe/issues/311">#311</a>)</p>
</li>
<li>
<p>Perform checks for modulo operations on integers (<a href="https://github.com/ethereum/fe/issues/312">#312</a>)</p>
</li>
<li>
<p>Perform over/underflow checks for exponentiation operations on integers (<a href="https://github.com/ethereum/fe/issues/313">#313</a>)</p>
</li>
</ul>
<h3 id="bugfixes-19"><a class="header" href="#bugfixes-19">Bugfixes</a></h3>
<ul>
<li>
<p>Properly reject <code>emit</code> not followed by an event invocation (<a href="https://github.com/ethereum/fe/issues/212">#212</a>)</p>
</li>
<li>
<p>Properly reject octal number literals (<a href="https://github.com/ethereum/fe/issues/222">#222</a>)</p>
</li>
<li>
<p>Properly reject code that tries to emit a non-existing event. (<a href="https://github.com/ethereum/fe/issues/250">#250</a>)</p>
<p>Example that now produces a compile time error:</p>
<pre><code>emit DoesNotExist()
</code></pre>
</li>
<li>
<p>Contracts that create other contracts can now include <code>__init__</code> functions.</p>
<p>See https://github.com/ethereum/fe/issues/284 (<a href="https://github.com/ethereum/fe/issues/304">#304</a>)</p>
</li>
<li>
<p>Prevent multiple types with same name in one module. (<a href="https://github.com/ethereum/fe/issues/317">#317</a>)</p>
<p>Examples that now produce compile time errors:</p>
<pre><code>type bar = u8
type bar = u16
</code></pre>
<p>or</p>
<pre><code>struct SomeStruct:
    some_field: u8

struct SomeStruct:
    other: u8
</code></pre>
<p>or</p>
<pre><code>contract SomeContract:
    some_field: u8

contract SomeContract:
    other: u8
</code></pre>
<p>Prevent multiple fields with same name in one struct.</p>
<p>Example that now produces a compile time error:</p>
<pre><code>struct SomeStruct:
    some_field: u8
    some_field: u8
</code></pre>
<p>Prevent variable definition in child scope when name already taken in parent scope.</p>
<p>Example that now produces a compile time error:</p>
<pre><code>pub fn bar():
    my_array: u256[3]
    sum: u256 = 0
    for i in my_array:
        sum: u256 = 0
</code></pre>
</li>
<li>
<p>The CLI was using the overwrite flag to enable Yul optimization.</p>
<p>i.e.</p>
<pre><code># Would both overwrite output files and run the Yul optimizer.
$ fe my_contract.fe --overwrite
</code></pre>
<p>Using the overwrite flag now only overwrites and optimization is enabled with the optimize flag. (<a href="https://github.com/ethereum/fe/issues/320">#320</a>)</p>
</li>
<li>
<p>Ensure analyzer rejects code that uses return values for <code>__init__</code> functions. (<a href="https://github.com/ethereum/fe/issues/323">#323</a>)</p>
<p>An example that now produces a compile time error:</p>
<pre><code>contract C:
    pub fn __init__() -&gt; i32:
        return 0
</code></pre>
</li>
<li>
<p>Properly reject calling an undefined function on an external contract (<a href="https://github.com/ethereum/fe/issues/324">#324</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-10"><a class="header" href="#internal-changes---for-fe-contributors-10">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Added the Uniswap demo contracts to our testing fixtures and validated their behaviour. (<a href="https://github.com/ethereum/fe/issues/179">#179</a>)</li>
<li>IDs added to AST nodes. (<a href="https://github.com/ethereum/fe/issues/315">#315</a>)</li>
<li>Failures in the Yul generation phase now panic; any failure is a bug. (<a href="https://github.com/ethereum/fe/issues/327">#327</a>)</li>
</ul>
<h2 id="020-alpha-borax-2021-02-27"><a class="header" href="#020-alpha-borax-2021-02-27">0.2.0-alpha &quot;Borax&quot; (2021-02-27)</a></h2>
<h3 id="features-25"><a class="header" href="#features-25">Features</a></h3>
<ul>
<li>
<p>Add support for string literals.</p>
<p>Example:</p>
<pre><code>fn get_ticker_symbol() -&gt; string3:
    return &quot;ETH&quot;
</code></pre>
<p>String literals are stored in and loaded from the compiled bytecode. (<a href="https://github.com/ethereum/fe/issues/186">#186</a>)</p>
</li>
<li>
<p>The CLI now compiles every contract in a module, not just the first one. (<a href="https://github.com/ethereum/fe/issues/197">#197</a>)</p>
<p>Sample compiler output with all targets enabled:</p>
<pre><code>output
|-- Bar
|   |-- Bar.bin
|   |-- Bar_abi.json
|   `-- Bar_ir.yul
|-- Foo
|   |-- Foo.bin
|   |-- Foo_abi.json
|   `-- Foo_ir.yul
|-- module.ast
`-- module.tokens
</code></pre>
</li>
<li>
<p>Add support for string type casts (<a href="https://github.com/ethereum/fe/issues/201">#201</a>)</p>
<p>Example:</p>
<pre><code>val: string100 = string100(&quot;foo&quot;)
</code></pre>
</li>
<li>
<p>Add basic support for structs. (<a href="https://github.com/ethereum/fe/issues/203">#203</a>)</p>
<p>Example:</p>
<pre><code>struct House:
    price: u256
    size: u256
    vacant: bool

contract City:

    pub fn get_price() -&gt; u256:
        building: House = House(300, 500, true)

        assert building.size == 500
        assert building.price == 300
        assert building.vacant

        return building.price
</code></pre>
</li>
<li>
<p>Added support for external contract calls. Contract definitions now
add a type to the module scope, which may be used to create contract
values with the contract's public functions as callable attributes. (<a href="https://github.com/ethereum/fe/issues/204">#204</a>)</p>
<p>Example:</p>
<pre><code class="language-python">contract Foo:
    pub fn build_array(a: u256, b: u256) -&gt; u256[3]:
        my_array: u256[3]
        my_array[0] = a
        my_array[1] = a * b
        my_array[2] = b
        return my_array

contract FooProxy:
    pub fn call_build_array(
        foo_address: address,
        a: u256,
        b: u256,
    ) -&gt; u256[3]:
        foo: Foo = Foo(foo_address)
        return foo.build_array(a, b)
</code></pre>
</li>
<li>
<p>Add support for <code>block</code>, <code>msg</code>, <code>chain</code>, and <code>tx</code> properties: (<a href="https://github.com/ethereum/fe/issues/208">#208</a>)</p>
<pre><code>block.coinbase: address
block.difficulty: u256
block.number: u256
block.timestamp: u256
chain.id: u256
msg.value: u256
tx.gas_price: u256
tx.origin: address
</code></pre>
<p>(Note that <code>msg.sender: address</code> was added previously.)</p>
<p>Example:</p>
<pre><code>fn post_fork() -&gt; bool:
    return block.number &gt; 2675000
</code></pre>
</li>
<li>
<p>The CLI now panics if an error is encountered during Yul compilation. (<a href="https://github.com/ethereum/fe/issues/218">#218</a>)</p>
</li>
<li>
<p>Support for contract creations.</p>
<p>Example of <code>create2</code>, which takes a <code>value</code> and address <code>salt</code> as parameters.</p>
<pre><code>contract Foo:
    pub fn get_my_num() -&gt; u256:
        return 42

contract FooFactory:
    pub fn create2_foo() -&gt; address:
        # value and salt
        foo: Foo = Foo.create2(0, 52)
        return address(foo)
</code></pre>
<p>Example of <code>create</code>, which just takes a <code>value</code> parameter.</p>
<pre><code>contract Foo:
    pub fn get_my_num() -&gt; u256:
        return 42

contract FooFactory:
    pub fn create_foo() -&gt; address:
        # value and salt
        foo: Foo = Foo.create(0)
        return address(foo)
</code></pre>
<p><em>Note: We do not yet support init parameters.</em> (<a href="https://github.com/ethereum/fe/issues/239">#239</a>)</p>
</li>
<li>
<p>Support updating individual struct fields in storage. (<a href="https://github.com/ethereum/fe/issues/246">#246</a>)</p>
<p>Example:</p>
<pre><code> pub fn update_house_price(price: u256):
        self.my_house.price = price
</code></pre>
</li>
<li>
<p>Implement global <code>keccak256</code> method. The method expects one parameter of <code>bytes[n]</code>
and returns the hash as an <code>u256</code>. In a future version <code>keccak256</code> will most likely
be moved behind an import so that it has to be imported (e.g. <code>from std.crypto import keccak256</code>). (<a href="https://github.com/ethereum/fe/issues/255">#255</a>)</p>
<p>Example:</p>
<pre><code>pub fn hash_single_byte(val: bytes[1]) -&gt; u256:
    return keccak256(val)
</code></pre>
</li>
<li>
<p>Require structs to be initialized using keyword arguments.</p>
<p>Example:</p>
<pre><code>struct House:
    vacant: bool
    price: u256
</code></pre>
<p>Previously, <code>House</code> could be instantiated as <code>House(true, 1000000)</code>.
With this change it is required to be instantiated like <code>House(vacant=true, price=1000000)</code></p>
<p>This ensures property assignment is less prone to get mixed up. It also makes struct
initialization visually stand out more from function calls. (<a href="https://github.com/ethereum/fe/issues/260">#260</a>)</p>
</li>
<li>
<p>Implement support for boolean <code>not</code> operator. (<a href="https://github.com/ethereum/fe/issues/264">#264</a>)</p>
<p>Example:</p>
<pre><code>if not covid_test.is_positive(person):
    allow_boarding(person)
</code></pre>
</li>
<li>
<p>Do over/underflow checks for additions (SafeMath).</p>
<p>With this change all additions (e.g <code>x + y</code>) for signed and unsigned
integers check for over- and underflows and revert if necessary. (<a href="https://github.com/ethereum/fe/issues/265">#265</a>)</p>
</li>
<li>
<p>Added a builtin function <code>abi_encode()</code> that can be used to encode structs. The return type is a
fixed-size array of bytes that is equal in size to the encoding. The type system does not support
dynamically-sized arrays yet, which is why we used fixed. (<a href="https://github.com/ethereum/fe/issues/266">#266</a>)</p>
<p>Example:</p>
<pre><code>struct House:
    price: u256
    size: u256
    rooms: u8
    vacant: bool

contract Foo:
    pub fn hashed_house() -&gt; u256:
        house: House = House(
            price=300,
            size=500,
            rooms=u8(20),
            vacant=true
        )
        return keccak256(house.abi_encode())
</code></pre>
</li>
<li>
<p>Perform over/underflow checks for subtractions (SafeMath). (<a href="https://github.com/ethereum/fe/issues/267">#267</a>)</p>
<p>With this change all subtractions (e.g <code>x - y</code>) for signed and unsigned
integers check for over- and underflows and revert if necessary.</p>
</li>
<li>
<p>Support for the boolean operations <code>and</code> and <code>or</code>. (<a href="https://github.com/ethereum/fe/issues/270">#270</a>)</p>
<p>Examples:</p>
<pre><code>contract Foo:
    pub fn bar(x: bool, y: bool) -&gt; bool:
        return x and y
</code></pre>
<pre><code>contract Foo:
    pub fn bar(x: bool, y: bool) -&gt; bool:
        return x or y
</code></pre>
<p>Support for <code>self.address</code>.</p>
<p>This expression returns the address of the current contract.</p>
<p>Example:</p>
<pre><code>contract Foo:
    pub fn bar() -&gt; address:
        return self.address
</code></pre>
</li>
</ul>
<h3 id="bugfixes-20"><a class="header" href="#bugfixes-20">Bugfixes</a></h3>
<ul>
<li>
<p>Perform type checking when calling event constructors</p>
<p>Previously, the following would not raise an error even though it should:</p>
<pre><code>contract Foo:
    event MyEvent:
        val_1: string100
        val_2: u8

    pub fn foo():
        emit MyEvent(&quot;foo&quot;, 1000)

</code></pre>
<p>Wit this change, the code fails with a type error as expected. (<a href="https://github.com/ethereum/fe/issues/202">#202</a>)</p>
</li>
<li>
<p>Fix bug where compilation of contracts without public functions would result in illegal YUL. (<a href="https://github.com/ethereum/fe/issues/219">#219</a>)</p>
<p>E.g without this change, the following doesn't compile to proper YUL</p>
<pre><code>contract Empty:
  lonely: u256
</code></pre>
</li>
<li>
<p>Ensure numeric literals can't exceed 256 bit range. Previously, this would result in a
non user friendly error at the YUL compilation stage. With this change it is caught
at the analyzer stage and presented to the user as a regular error. (<a href="https://github.com/ethereum/fe/issues/225">#225</a>)</p>
</li>
<li>
<p>Fix crash when return is used without value.</p>
<p>These two methods should both be treated as returning <code>()</code></p>
<pre><code>  pub fn explicit_return():
    return

  pub fn implicit():
    pass
</code></pre>
<p>Without this change, the <code>explicit_return</code> crashes the compiler. (<a href="https://github.com/ethereum/fe/issues/261">#261</a>)</p>
</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-11"><a class="header" href="#internal-changes---for-fe-contributors-11">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Renamed the fe-semantics library to fe-analyzer. (<a href="https://github.com/ethereum/fe/issues/207">#207</a>)</li>
<li>Runtime testing utilities. (<a href="https://github.com/ethereum/fe/issues/243">#243</a>)</li>
<li>Values are stored more efficiently in storage. (<a href="https://github.com/ethereum/fe/issues/251">#251</a>)</li>
</ul>
<h2 id="010-alpha-amethyst-2021-01-20"><a class="header" href="#010-alpha-amethyst-2021-01-20">0.1.0-alpha &quot;Amethyst&quot; (2021-01-20)</a></h2>
<p><strong>WARNING: This is an alpha version to share the development progress with developers and enthusiasts. It is NOT yet intended to be used for anything serious. At this point Fe is missing a lot of features and has a lot of bugs instead.</strong></p>
<p>This is the first <strong>alpha</strong> release and kicks off our release schedule which will be one release every month in the future. Since we have just started tracking progress on changes, the following list of changes is incomplete, but will appropriately document progress between releases from now on.</p>
<h3 id="features-26"><a class="header" href="#features-26">Features</a></h3>
<ul>
<li>
<p>Added support for <code>for loop</code>, allows iteration over static arrays. (<a href="https://github.com/ethereum/fe/issues/134">#134</a>)</p>
</li>
<li>
<p>Enforce bounds on numeric literals in type constructors.</p>
<p>For instance calling <code>u8(1000)</code> or <code>i8(-250)</code> will give an error because
the literals <code>1000</code> and <code>-250</code> do not fit into <code>u8</code> or <code>i8</code>. (<a href="https://github.com/ethereum/fe/issues/145">#145</a>)</p>
</li>
<li>
<p>Added builtin copying methods <code>clone()</code> and <code>to_mem()</code> to reference types. (<a href="https://github.com/ethereum/fe/issues/155">#155</a>)</p>
<p>usage:</p>
<pre><code># copy a segment of storage into memory and assign the new pointer
my_mem_array = self.my_sto_array.to_mem()

# copy a segment of memory into another segment of memory and assign the new pointer
my_other_mem_array = my_mem_array.clone()
</code></pre>
</li>
<li>
<p>Support emitting JSON ABI via <code>--emit abi</code>.
The default value of <code>--emit</code> is now <code>abi,bytecode</code>. (<a href="https://github.com/ethereum/fe/issues/160">#160</a>)</p>
</li>
<li>
<p>Ensure integer type constructor reject all expressions that aren't a numeric literal.
For instance, previously the compiler would not reject the following code even though it could not be guaranteed that <code>val</code> would fit into an <code>u16</code>.</p>
<pre><code>pub fn bar(val: u8) -&gt; u16:
        return u16(val)
</code></pre>
<p>Now such code is rejected and integer type constructor do only work with numeric literals such as <code>1</code> or <code>-3</code>. (<a href="https://github.com/ethereum/fe/issues/163">#163</a>)</p>
</li>
<li>
<p>Support for ABI decoding of all array type. (<a href="https://github.com/ethereum/fe/issues/172">#172</a>)</p>
</li>
<li>
<p>Support for value assignments in declaration.</p>
<p>Previously, this code would fail:</p>
<pre><code>another_reference: u256[10] = my_array
</code></pre>
<p>As a workaround declaration and assignment could be split apart.</p>
<pre><code>another_reference: u256[10]
another_reference = my_array
</code></pre>
<p>With this change, the shorter declaration with assignment syntax is supported. (<a href="https://github.com/ethereum/fe/issues/173">#173</a>)</p>
</li>
</ul>
<h3 id="improved-documentation-6"><a class="header" href="#improved-documentation-6">Improved Documentation</a></h3>
<ul>
<li>Point to examples in the README (<a href="https://github.com/ethereum/fe/issues/162">#162</a>)</li>
<li>Overhaul README page to better reflect the current state of the project. (<a href="https://github.com/ethereum/fe/issues/177">#177</a>)</li>
<li>Added descriptions of the <code>to_mem</code> and <code>clone</code> functions to the spec. (<a href="https://github.com/ethereum/fe/issues/195">#195</a>)</li>
</ul>
<h3 id="internal-changes---for-fe-contributors-12"><a class="header" href="#internal-changes---for-fe-contributors-12">Internal Changes - for Fe Contributors</a></h3>
<ul>
<li>Updated the Solidity backend to v0.8.0. (<a href="https://github.com/ethereum/fe/issues/169">#169</a>)</li>
<li>Run CI tests on Mac and support creating Mac binaries for releases. (<a href="https://github.com/ethereum/fe/issues/178">#178</a>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.</p>
<p>We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to a positive environment for our
community include:</p>
<ul>
<li>Demonstrating empathy and kindness toward other people</li>
<li>Being respectful of differing opinions, viewpoints, and experiences</li>
<li>Giving and gracefully accepting constructive feedback</li>
<li>Accepting responsibility and apologizing to those affected by our mistakes,
and learning from the experience</li>
<li>Focusing on what is best not just for us as individuals, but for the
overall community</li>
</ul>
<p>Examples of unacceptable behavior include:</p>
<ul>
<li>The use of sexualized language or imagery, and sexual attention or
advances of any kind</li>
<li>Trolling, insulting or derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or email
address, without their explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="enforcement-responsibilities"><a class="header" href="#enforcement-responsibilities">Enforcement Responsibilities</a></h2>
<p>Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.</p>
<p>Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
piper@pipermerriam.com.
All complaints will be reviewed and investigated promptly and fairly.</p>
<p>All community leaders are obligated to respect the privacy and security of the
reporter of any incident.</p>
<h2 id="enforcement-guidelines"><a class="header" href="#enforcement-guidelines">Enforcement Guidelines</a></h2>
<p>Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:</p>
<h3 id="1-correction"><a class="header" href="#1-correction">1. Correction</a></h3>
<p><strong>Community Impact</strong>: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.</p>
<p><strong>Consequence</strong>: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.</p>
<h3 id="2-warning"><a class="header" href="#2-warning">2. Warning</a></h3>
<p><strong>Community Impact</strong>: A violation through a single incident or series
of actions.</p>
<p><strong>Consequence</strong>: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.</p>
<h3 id="3-temporary-ban"><a class="header" href="#3-temporary-ban">3. Temporary Ban</a></h3>
<p><strong>Community Impact</strong>: A serious violation of community standards, including
sustained inappropriate behavior.</p>
<p><strong>Consequence</strong>: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.</p>
<h3 id="4-permanent-ban"><a class="header" href="#4-permanent-ban">4. Permanent Ban</a></h3>
<p><strong>Community Impact</strong>: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.</p>
<p><strong>Consequence</strong>: A permanent ban from any sort of public interaction within
the community.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="https://www.contributor-covenant.org">Contributor Covenant</a>,
version 2.0, available at
<a href="https://www.contributor-covenant.org/version/2/0/code_of_conduct.html">https://www.contributor-covenant.org/version/2/0/code_of_conduct.html</a>.</p>
<p>Community Impact Guidelines were inspired by 
<a href="https://github.com/mozilla/diversity">Mozilla's code of conduct enforcement ladder</a>.</p>
<p>For answers to common questions about this code of conduct, see the FAQ at
<a href="https://www.contributor-covenant.org/faq">https://www.contributor-covenant.org/faq</a>. Translations are available 
at <a href="https://www.contributor-covenant.org/translations">https://www.contributor-covenant.org/translations</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/custom-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
