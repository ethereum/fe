pub enum MyEnum {
    Unit
    UnitTuple()
    Tuple(u32, u256)
}

pub enum MyEnumNested  {
    Tuple(u32, u256)
    Nested(MyEnum)
}

pub enum Tuple2{
    Value(MyEnum, MyEnum)
}

pub enum State {
    Continue
    Done
}

contract Foo {
    my_enum: MyEnumNested
    
    pub fn simple_match(x: u32, y: u256) -> u256 {
        let my_enum: MyEnum = MyEnum::Tuple(x, y);
        match my_enum {
            MyEnum::Unit | MyEnum::UnitTuple() => {
                return 0
            }
            MyEnum::Tuple(x1, y1) => {
                return u256(x1) + y1
            }
        }
    }
    
    pub fn nested_match(x: u32, y: u256) -> u256 {
        let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Tuple(x, y))
        match nested {
            MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
                return u256(x1) + y1
            }
            MyEnumNested::Nested(MyEnum::Unit | MyEnum::UnitTuple()) => {
                return 0
            }
        }
    }

    pub fn nested_match2() -> u256 {
        let tup: Tuple2 = Tuple2::Value(MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
        let res: u256 = 0
        match tup {
            Tuple2::Value(MyEnum::Unit, MyEnum::Tuple(x, y)) | Tuple2::Value(MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
                res = u256(x) + y
            }
            _ => {
                return 0
            }
        }
        
        return res
    }
    
    pub fn tuple_match() -> u256 {
        let tup: (MyEnum, MyEnum) = (MyEnum::Tuple(1, 2), MyEnum::UnitTuple())
        match tup {
            (MyEnum::Unit, MyEnum::Tuple(x, y)) | (MyEnum::Tuple(x, y), MyEnum::UnitTuple()) => {
                return u256(x) + y
            }

            _ => {
                return 0
            }
        }
    }

    pub fn boolean_literal_match(b1: bool, b2: bool) -> u256 {
        match (b1, b2) {
            (true, true) => {
                return 2
            }
            (true, false) | (false, true) => {
                return 1
            }
            (false, false) => {
                return 0
            }
        }
    }

    pub fn wild_card() -> u256 {
        let nested: MyEnumNested = MyEnumNested::Nested(MyEnum::Unit)
        match nested {
            MyEnumNested::Nested(MyEnum::UnitTuple() | MyEnum::Tuple(_, _)) => {
                return 100
            }
            _ => {
                return 0
            }
        }
    }
    
    pub fn match_in_if() -> u256 {
        let res: u256 = 0
        let my_enum: MyEnum = MyEnum::Tuple(1, 2);

        if true {
            match my_enum {
                MyEnum::Tuple(x, y) => {
                    res = u256(x) + y
                }

                _ => {
                    res = 0
                }
            }
        } else {
            res = 100
        }

        return res

    }
    
    pub fn match_in_loop() -> u256 {
        let res: u256 = 0
        let state: State = State::Continue 

        let my_array: Array<u256, 3> = [0; 3]
        my_array[0] = 5
        my_array[1] = 10
        my_array[2] = 15

        for i in my_array {
            match state {
                State::Continue => {}
                State::Done => {
                    break
                }
            }

            res += i
            if res == 15 {
                state = State::Done
            }
        }

        return res
    }
    
    pub fn rest_pattern_head(x: u32, y: u256) -> u256 {
        let pat: (MyEnum, MyEnum, MyEnum, MyEnum) = (MyEnum::Unit, MyEnum::Unit, MyEnum::Unit, MyEnum::Tuple(x, y))
        match pat {
            (.., MyEnum::Tuple(x1, y1)) => {
                return u256(x1) + y1
            }
            _ => {
                return 0
            }
        }
    }

    pub fn rest_pattern_tail(x: u32, y: u256) -> u256 {
        let pat: (MyEnum, MyEnum, MyEnum, MyEnum) = (MyEnum::Tuple(x, y), MyEnum::Unit, MyEnum::Unit, MyEnum::Unit)
        match pat {
            (MyEnum::Tuple(x1, y1), ..) => {
                return u256(x1) + y1
            }
            _ => {
                return 0
            }
        }
    }

    pub fn rest_pattern_middle(x: u32, y: u256) -> u256 {
        let pat: (MyEnum, MyEnum, MyEnum, MyEnum) = (MyEnum::Tuple(x, y), MyEnum::Unit, MyEnum::Unit, MyEnum::Tuple(x, y))
        match pat {
            (MyEnum::Tuple(x1, y1), .., MyEnum::Tuple(x2, y2)) => {
                return u256(x1) + y1 + u256(x2) + y2
            }
            _ => {
                return 0
            }
        }
    }

    pub fn enum_storage(self, x:u32, y: u256, b: bool) -> u256 {
        if b {
            self.my_enum = MyEnumNested::Nested(MyEnum::Tuple(x, y))
        } else {
            self.my_enum = MyEnumNested::Nested(MyEnum::Unit)
        }
        
        match self.my_enum {
            MyEnumNested::Tuple(x1, y1) | MyEnumNested::Nested(MyEnum::Tuple(x1, y1)) => {
                return u256(x1) + y1
            }
            _ => {
                return 100
            }
        }
    }
}