searchState.loadedDescShard("fe_parser", 0, "Contains the error value\nContains the success value\n<code>Parser</code> maintains the parsing state, such as the token …\nReturns back tracking parser.\nAssert that the next token kind it matches the expected …\nThe diagnostics (errors and warnings) emitted during …\nReturns <code>true</code> if the parser has reached the end of the file.\nEnter a “block”, which is a brace-enclosed list of …\nEmit an error diagnostic, but don’t stop parsing\nIf the next token matches the expected kind, return it. …\nConsumes newlines and semicolons. Returns Ok if one or …\nLike <code>Parser::expect</code>, but with additional notes to be …\nEmit a “fancy” error diagnostic with any number of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a [<code>codespan_reporting::Diagnostic::Label</code>]\nCreate a new parser for a source code string and …\nReturn the next token, or an error if we’ve reached the …\nIf the next token matches the expected kind, return it. …\nParse a <code>Module</code> from the file content string.\nTake a peek at the next token kind. Returns <code>None</code> if we’…\nTake a peek at the next token kind without consuming it, …\nCreate a primary label with the given message. This will …\nCreate a secondary label with the given message. This will …\nSplit the next token into two tokens, returning the first. …\nEmit an “unexpected token” error diagnostic with the …\nstruct or contract field, with optional ‘pub’ and ‘…\nRepresents a literal pattern. e.g., <code>true</code>.\nRepresents or pattern. e.g., <code>EnumUnit | EnumTuple(_, _, _)</code>\nRepresents unit variant pattern. e.g., <code>Enum::Unit</code>.\nRepresents struct or struct variant destructuring pattern. …\nRepresents tuple variant pattern. e.g., …\nRest pattern. e.g., <code>..</code>\nA <code>SmolStr</code> is a string type that has the following …\nTuple variant. E.g., <code>Baz(u32, i32)</code> in\nRepresents tuple destructuring pattern. e.g., <code>(x, y, z)</code>.\nUnit variant. E.g., <code>Bar</code> in\nEnum variant definition.\nEnum variant kind.\nRepresents a wildcard pattern <code>_</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs inline variant of <code>SmolStr</code>.\nParse a contract definition.\nParse call arguments\nParse an expression, starting with the next token.\nParse an expression, stopping if/when we reach an operator …\nParse an <code>assert</code> statement.\nParse a function definition. The optional <code>pub</code> qualifier …\nParse a function definition without a body. The optional …\nParse a <code>for</code> statement.\nParse a single generic function parameter (eg. <code>T:SomeTrait</code> …\nParse an angle-bracket-wrapped list of generic arguments …\nParse an <code>if</code> statement.\nParse a <code>match</code> statement.\nParse a <code>return</code> statement.\nParse a <code>revert</code> statement.\nParse a <code>continue</code>, <code>break</code>, <code>pass</code>, or <code>revert</code> statement.\nParse a function-level statement.\nParse an <code>unsafe</code> block.\nParse a <code>while</code> statement.\nParse a constant, e.g. <code>const MAGIC_NUMBER: u256 = 4711</code>.\nParse a <code>Module</code>.\nParse a <code>ModuleStmt</code>.\nParse a <code>pragma &lt;version-requirement&gt;</code> statement.\nParse a <code>use</code> statement.\nParse a <code>use</code> tree.\nParse a [<code>ModuleStmt::Enum</code>].\nParse a field for a struct or contract. The leading …\nParse an angle-bracket-wrapped list of generic arguments …\nParse an impl block.\nParse an optional qualifier (<code>pub</code>, <code>const</code>, or <code>idx</code>).\nReturns path and trailing <code>::</code> token, if present.\nParse a [<code>ModuleStmt::Struct</code>].\nParse a trait definition.\nParse a type alias definition, e.g. …\nParse a type description, e.g. <code>u8</code> or <code>Map&lt;address, u256&gt;</code>.\nParse a variant for a enum definition.\nReturn a user-friendly description of the token kind. E.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new lexer with the given source code string.\nReturn the full source code string that’s being …\nAn exclusive span of byte offsets in a source file.\nA byte offset specifying the exclusive end of a span.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA byte offset specifying the inclusive start of a span.")